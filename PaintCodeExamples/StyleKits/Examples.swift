//
//  Examples.swift
//  PaintCodeExamples
//
//  Created by Shane Whitehead on 25/8/18.
//  Copyright Â© 2018 Me. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class Examples : NSObject {

    //// Cache

    private struct Cache {
        static var imageOfActiveCallBlank: UIImage?
        static var activeCallBlankTargets: [AnyObject]?
        static var imageOfRoundButton: UIImage?
        static var roundButtonTargets: [AnyObject]?
        static var imageOfSOSRoundButton: UIImage?
        static var sOSRoundButtonTargets: [AnyObject]?
        static var imageOfGreenRoundButton: UIImage?
        static var greenRoundButtonTargets: [AnyObject]?
        static var imageOfPanelBackground: UIImage?
        static var panelBackgroundTargets: [AnyObject]?
        static var imageOfIncomingMessageBubble: UIImage?
        static var incomingMessageBubbleTargets: [AnyObject]?
        static var imageOfOutgoingMessageBubble: UIImage?
        static var outgoingMessageBubbleTargets: [AnyObject]?
    }

    //// Drawing Methods

    @objc dynamic public class func drawKeyPadAudioRoutes(frame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let actionNormalColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let actionPressedColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let actionForegroundColor = enabled ? (pressed ? actionPressedColor : actionNormalColor) : gray


        //// Subframes
        let bluetooth: CGRect = CGRect(x: frame.minX + 5, y: frame.minY + 5, width: fastFloor((frame.width - 5) * 0.94737 + 0.5), height: fastFloor((frame.height - 5) * 0.94737 + 0.5))


        //// bluetooth
        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: bluetooth.minX + fastFloor(bluetooth.width * 0.00000 + 0.5), y: bluetooth.minY + fastFloor(bluetooth.height * 0.00000 + 0.5), width: fastFloor(bluetooth.width * 1.00000 + 0.5) - fastFloor(bluetooth.width * 0.00000 + 0.5), height: fastFloor(bluetooth.height * 1.00000 + 0.5) - fastFloor(bluetooth.height * 0.00000 + 0.5)))
        keyPadBackroundColor.setFill()
        normalPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: bluetooth.minX + 0.64444 * bluetooth.width, y: bluetooth.minY + 0.23958 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.64444 * bluetooth.width, y: bluetooth.minY + 0.44514 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.56076 * bluetooth.width, y: bluetooth.minY + 0.36146 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.52951 * bluetooth.width, y: bluetooth.minY + 0.39306 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.63542 * bluetooth.width, y: bluetooth.minY + 0.49861 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.52917 * bluetooth.width, y: bluetooth.minY + 0.60521 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.56076 * bluetooth.width, y: bluetooth.minY + 0.63646 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.64444 * bluetooth.width, y: bluetooth.minY + 0.55243 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.64444 * bluetooth.width, y: bluetooth.minY + 0.76111 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.68229 * bluetooth.width, y: bluetooth.minY + 0.72292 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.78646 * bluetooth.width, y: bluetooth.minY + 0.61806 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.80208 * bluetooth.width, y: bluetooth.minY + 0.60243 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.78646 * bluetooth.width, y: bluetooth.minY + 0.58681 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.69792 * bluetooth.width, y: bluetooth.minY + 0.49861 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.78611 * bluetooth.width, y: bluetooth.minY + 0.41007 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.80174 * bluetooth.width, y: bluetooth.minY + 0.39444 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.78576 * bluetooth.width, y: bluetooth.minY + 0.37882 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.68229 * bluetooth.width, y: bluetooth.minY + 0.27674 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.64444 * bluetooth.width, y: bluetooth.minY + 0.23958 * bluetooth.height))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: bluetooth.minX + 0.68889 * bluetooth.width, y: bluetooth.minY + 0.34549 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.73889 * bluetooth.width, y: bluetooth.minY + 0.39444 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.68889 * bluetooth.width, y: bluetooth.minY + 0.44479 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.68889 * bluetooth.width, y: bluetooth.minY + 0.34549 * bluetooth.height))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: bluetooth.minX + 0.68889 * bluetooth.width, y: bluetooth.minY + 0.55208 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.73958 * bluetooth.width, y: bluetooth.minY + 0.60243 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.68889 * bluetooth.width, y: bluetooth.minY + 0.65347 * bluetooth.height))
        bezier2Path.addLine(to: CGPoint(x: bluetooth.minX + 0.68889 * bluetooth.width, y: bluetooth.minY + 0.55208 * bluetooth.height))
        bezier2Path.close()
        actionForegroundColor.setFill()
        bezier2Path.fill()


        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: bluetooth.minX + 0.45764 * bluetooth.width, y: bluetooth.minY + 0.24444 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.42847 * bluetooth.width, y: bluetooth.minY + 0.25799 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.44753 * bluetooth.width, y: bluetooth.minY + 0.24444 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.43702 * bluetooth.width, y: bluetooth.minY + 0.24931 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.29931 * bluetooth.width, y: bluetooth.minY + 0.38681 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.28889 * bluetooth.width, y: bluetooth.minY + 0.41389 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.29219 * bluetooth.width, y: bluetooth.minY + 0.39310 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.28889 * bluetooth.width, y: bluetooth.minY + 0.40530 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.28889 * bluetooth.width, y: bluetooth.minY + 0.56389 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.29896 * bluetooth.width, y: bluetooth.minY + 0.59028 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.28889 * bluetooth.width, y: bluetooth.minY + 0.57240 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.29240 * bluetooth.width, y: bluetooth.minY + 0.58451 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.42778 * bluetooth.width, y: bluetooth.minY + 0.71875 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.45729 * bluetooth.width, y: bluetooth.minY + 0.73333 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.43950 * bluetooth.width, y: bluetooth.minY + 0.73064 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.45030 * bluetooth.width, y: bluetooth.minY + 0.73333 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.48889 * bluetooth.width, y: bluetooth.minY + 0.69236 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.47582 * bluetooth.width, y: bluetooth.minY + 0.73333 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.48889 * bluetooth.width, y: bluetooth.minY + 0.71641 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.48889 * bluetooth.width, y: bluetooth.minY + 0.28125 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.45764 * bluetooth.width, y: bluetooth.minY + 0.24444 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.48889 * bluetooth.width, y: bluetooth.minY + 0.25595 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.47266 * bluetooth.width, y: bluetooth.minY + 0.24444 * bluetooth.height))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: bluetooth.minX + 0.22222 * bluetooth.width, y: bluetooth.minY + 0.38854 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.18854 * bluetooth.width, y: bluetooth.minY + 0.42222 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.20360 * bluetooth.width, y: bluetooth.minY + 0.38854 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.18854 * bluetooth.width, y: bluetooth.minY + 0.40360 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.18854 * bluetooth.width, y: bluetooth.minY + 0.55556 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.22222 * bluetooth.width, y: bluetooth.minY + 0.58924 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.18854 * bluetooth.width, y: bluetooth.minY + 0.57418 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.20360 * bluetooth.width, y: bluetooth.minY + 0.58924 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.27187 * bluetooth.width, y: bluetooth.minY + 0.58924 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.26667 * bluetooth.width, y: bluetooth.minY + 0.56389 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.26823 * bluetooth.width, y: bluetooth.minY + 0.58051 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.26667 * bluetooth.width, y: bluetooth.minY + 0.57122 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.26667 * bluetooth.width, y: bluetooth.minY + 0.41389 * bluetooth.height))
        bezier3Path.addCurve(to: CGPoint(x: bluetooth.minX + 0.27222 * bluetooth.width, y: bluetooth.minY + 0.38854 * bluetooth.height), controlPoint1: CGPoint(x: bluetooth.minX + 0.26667 * bluetooth.width, y: bluetooth.minY + 0.40660 * bluetooth.height), controlPoint2: CGPoint(x: bluetooth.minX + 0.26849 * bluetooth.width, y: bluetooth.minY + 0.39735 * bluetooth.height))
        bezier3Path.addLine(to: CGPoint(x: bluetooth.minX + 0.22222 * bluetooth.width, y: bluetooth.minY + 0.38854 * bluetooth.height))
        bezier3Path.close()
        actionForegroundColor.setFill()
        bezier3Path.fill()
    }

    @objc dynamic public class func drawKeyPadBack(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 37.78, y: 35))
        bezierPath.addLine(to: CGPoint(x: 25, y: 50))
        bezierPath.addLine(to: CGPoint(x: 37.78, y: 65))
        bezierPath.addLine(to: CGPoint(x: 71.03, y: 65))
        bezierPath.addCurve(to: CGPoint(x: 75, y: 61), controlPoint1: CGPoint(x: 73.21, y: 65), controlPoint2: CGPoint(x: 75, y: 63.2))
        bezierPath.addLine(to: CGPoint(x: 75, y: 39))
        bezierPath.addCurve(to: CGPoint(x: 71.03, y: 35), controlPoint1: CGPoint(x: 75, y: 36.8), controlPoint2: CGPoint(x: 73.21, y: 35))
        bezierPath.addLine(to: CGPoint(x: 37.78, y: 35))
        bezierPath.close()
        keyPadBackroundColor.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 49.63, y: 43.59))
        bezier2Path.addLine(to: CGPoint(x: 48.22, y: 45))
        bezier2Path.addLine(to: CGPoint(x: 53.51, y: 50.29))
        bezier2Path.addLine(to: CGPoint(x: 48.22, y: 55.57))
        bezier2Path.addLine(to: CGPoint(x: 49.63, y: 56.99))
        bezier2Path.addLine(to: CGPoint(x: 54.92, y: 51.7))
        bezier2Path.addLine(to: CGPoint(x: 60.21, y: 56.99))
        bezier2Path.addLine(to: CGPoint(x: 61.62, y: 55.57))
        bezier2Path.addLine(to: CGPoint(x: 56.33, y: 50.29))
        bezier2Path.addLine(to: CGPoint(x: 61.62, y: 45))
        bezier2Path.addLine(to: CGPoint(x: 60.21, y: 43.59))
        bezier2Path.addLine(to: CGPoint(x: 54.92, y: 48.87))
        bezier2Path.addLine(to: CGPoint(x: 49.63, y: 43.59))
        bezier2Path.close()
        textForegroundColor.setFill()
        bezier2Path.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad07(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "7"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "PQRS"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad07(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "7"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad03(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "3"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "DEF"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad06(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "6"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "MNO"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadSpeaker(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let actionNormalColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let actionPressedColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let actionForegroundColor = enabled ? (pressed ? actionPressedColor : actionNormalColor) : gray

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        normalPath.fill()


        //// Speaker
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 49.19, y: 28))
        bezierPath.addCurve(to: CGPoint(x: 46.56, y: 29.22), controlPoint1: CGPoint(x: 48.28, y: 28), controlPoint2: CGPoint(x: 47.33, y: 28.44))
        bezierPath.addLine(to: CGPoint(x: 34.94, y: 40.81))
        bezierPath.addCurve(to: CGPoint(x: 34, y: 43.25), controlPoint1: CGPoint(x: 34.3, y: 41.38), controlPoint2: CGPoint(x: 34, y: 42.48))
        bezierPath.addLine(to: CGPoint(x: 34, y: 56.75))
        bezierPath.addCurve(to: CGPoint(x: 34.91, y: 59.12), controlPoint1: CGPoint(x: 34, y: 57.52), controlPoint2: CGPoint(x: 34.32, y: 58.61))
        bezierPath.addLine(to: CGPoint(x: 46.5, y: 70.69))
        bezierPath.addCurve(to: CGPoint(x: 49.16, y: 72), controlPoint1: CGPoint(x: 47.55, y: 71.76), controlPoint2: CGPoint(x: 48.53, y: 72))
        bezierPath.addCurve(to: CGPoint(x: 52, y: 68.31), controlPoint1: CGPoint(x: 50.82, y: 72), controlPoint2: CGPoint(x: 52, y: 70.48))
        bezierPath.addLine(to: CGPoint(x: 52, y: 31.31))
        bezierPath.addCurve(to: CGPoint(x: 49.19, y: 28), controlPoint1: CGPoint(x: 52, y: 29.04), controlPoint2: CGPoint(x: 50.54, y: 28))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 63.28, y: 31.81))
        bezierPath.addCurve(to: CGPoint(x: 62.46, y: 32.68), controlPoint1: CGPoint(x: 62.84, y: 31.89), controlPoint2: CGPoint(x: 62.51, y: 32.24))
        bezierPath.addCurve(to: CGPoint(x: 63.06, y: 33.72), controlPoint1: CGPoint(x: 62.41, y: 33.12), controlPoint2: CGPoint(x: 62.65, y: 33.55))
        bezierPath.addCurve(to: CGPoint(x: 73.06, y: 50), controlPoint1: CGPoint(x: 69.01, y: 36.72), controlPoint2: CGPoint(x: 73.06, y: 42.87))
        bezierPath.addCurve(to: CGPoint(x: 63.06, y: 66.28), controlPoint1: CGPoint(x: 73.06, y: 57.13), controlPoint2: CGPoint(x: 69.01, y: 63.28))
        bezierPath.addCurve(to: CGPoint(x: 62.39, y: 67.12), controlPoint1: CGPoint(x: 62.7, y: 66.41), controlPoint2: CGPoint(x: 62.44, y: 66.73))
        bezierPath.addCurve(to: CGPoint(x: 62.87, y: 68.08), controlPoint1: CGPoint(x: 62.35, y: 67.5), controlPoint2: CGPoint(x: 62.54, y: 67.88))
        bezierPath.addCurve(to: CGPoint(x: 63.94, y: 68.06), controlPoint1: CGPoint(x: 63.2, y: 68.28), controlPoint2: CGPoint(x: 63.61, y: 68.27))
        bezierPath.addCurve(to: CGPoint(x: 75.06, y: 50), controlPoint1: CGPoint(x: 70.54, y: 64.73), controlPoint2: CGPoint(x: 75.06, y: 57.89))
        bezierPath.addCurve(to: CGPoint(x: 63.94, y: 31.94), controlPoint1: CGPoint(x: 75.06, y: 42.11), controlPoint2: CGPoint(x: 70.54, y: 35.27))
        bezierPath.addCurve(to: CGPoint(x: 63.38, y: 31.81), controlPoint1: CGPoint(x: 63.77, y: 31.84), controlPoint2: CGPoint(x: 63.57, y: 31.8))
        bezierPath.addCurve(to: CGPoint(x: 63.28, y: 31.81), controlPoint1: CGPoint(x: 63.34, y: 31.81), controlPoint2: CGPoint(x: 63.31, y: 31.81))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 59.72, y: 37.12))
        bezierPath.addCurve(to: CGPoint(x: 58.86, y: 37.97), controlPoint1: CGPoint(x: 59.27, y: 37.18), controlPoint2: CGPoint(x: 58.92, y: 37.53))
        bezierPath.addCurve(to: CGPoint(x: 59.44, y: 39.03), controlPoint1: CGPoint(x: 58.79, y: 38.41), controlPoint2: CGPoint(x: 59.03, y: 38.85))
        bezierPath.addCurve(to: CGPoint(x: 66, y: 50), controlPoint1: CGPoint(x: 63.34, y: 41.14), controlPoint2: CGPoint(x: 66, y: 45.25))
        bezierPath.addCurve(to: CGPoint(x: 59.47, y: 60.97), controlPoint1: CGPoint(x: 66, y: 54.74), controlPoint2: CGPoint(x: 63.35, y: 58.86))
        bezierPath.addCurve(to: CGPoint(x: 59.08, y: 62.33), controlPoint1: CGPoint(x: 58.98, y: 61.23), controlPoint2: CGPoint(x: 58.81, y: 61.84))
        bezierPath.addCurve(to: CGPoint(x: 60.44, y: 62.72), controlPoint1: CGPoint(x: 59.34, y: 62.81), controlPoint2: CGPoint(x: 59.95, y: 62.99))
        bezierPath.addCurve(to: CGPoint(x: 68, y: 50), controlPoint1: CGPoint(x: 64.95, y: 60.27), controlPoint2: CGPoint(x: 68, y: 55.48))
        bezierPath.addCurve(to: CGPoint(x: 60.41, y: 37.25), controlPoint1: CGPoint(x: 68, y: 44.5), controlPoint2: CGPoint(x: 64.94, y: 39.7))
        bezierPath.addCurve(to: CGPoint(x: 59.81, y: 37.12), controlPoint1: CGPoint(x: 60.23, y: 37.15), controlPoint2: CGPoint(x: 60.02, y: 37.11))
        bezierPath.addCurve(to: CGPoint(x: 59.72, y: 37.12), controlPoint1: CGPoint(x: 59.78, y: 37.12), controlPoint2: CGPoint(x: 59.75, y: 37.12))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 28, y: 40.97))
        bezierPath.addCurve(to: CGPoint(x: 24.97, y: 44), controlPoint1: CGPoint(x: 26.32, y: 40.97), controlPoint2: CGPoint(x: 24.97, y: 42.32))
        bezierPath.addLine(to: CGPoint(x: 24.97, y: 56))
        bezierPath.addCurve(to: CGPoint(x: 28, y: 59.03), controlPoint1: CGPoint(x: 24.97, y: 57.68), controlPoint2: CGPoint(x: 26.32, y: 59.03))
        bezierPath.addLine(to: CGPoint(x: 32.47, y: 59.03))
        bezierPath.addCurve(to: CGPoint(x: 32, y: 56.75), controlPoint1: CGPoint(x: 32.14, y: 58.25), controlPoint2: CGPoint(x: 32, y: 57.41))
        bezierPath.addLine(to: CGPoint(x: 32, y: 43.25))
        bezierPath.addCurve(to: CGPoint(x: 32.5, y: 40.97), controlPoint1: CGPoint(x: 32, y: 42.59), controlPoint2: CGPoint(x: 32.16, y: 41.76))
        bezierPath.addLine(to: CGPoint(x: 28, y: 40.97))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 55.53, y: 43.41))
        bezierPath.addCurve(to: CGPoint(x: 54.66, y: 44.35), controlPoint1: CGPoint(x: 55.05, y: 43.46), controlPoint2: CGPoint(x: 54.68, y: 43.86))
        bezierPath.addCurve(to: CGPoint(x: 55.44, y: 45.38), controlPoint1: CGPoint(x: 54.63, y: 44.84), controlPoint2: CGPoint(x: 54.96, y: 45.27))
        bezierPath.addCurve(to: CGPoint(x: 59, y: 50), controlPoint1: CGPoint(x: 57.48, y: 45.91), controlPoint2: CGPoint(x: 59, y: 47.78))
        bezierPath.addCurve(to: CGPoint(x: 55.44, y: 54.62), controlPoint1: CGPoint(x: 59, y: 52.22), controlPoint2: CGPoint(x: 57.48, y: 54.09))
        bezierPath.addCurve(to: CGPoint(x: 54.72, y: 55.84), controlPoint1: CGPoint(x: 54.9, y: 54.76), controlPoint2: CGPoint(x: 54.58, y: 55.31))
        bezierPath.addCurve(to: CGPoint(x: 55.94, y: 56.56), controlPoint1: CGPoint(x: 54.86, y: 56.38), controlPoint2: CGPoint(x: 55.4, y: 56.7))
        bezierPath.addCurve(to: CGPoint(x: 61, y: 50), controlPoint1: CGPoint(x: 58.85, y: 55.8), controlPoint2: CGPoint(x: 61, y: 53.14))
        bezierPath.addCurve(to: CGPoint(x: 55.94, y: 43.44), controlPoint1: CGPoint(x: 61, y: 46.86), controlPoint2: CGPoint(x: 58.85, y: 44.2))
        bezierPath.addCurve(to: CGPoint(x: 55.53, y: 43.41), controlPoint1: CGPoint(x: 55.8, y: 43.4), controlPoint2: CGPoint(x: 55.67, y: 43.39))
        bezierPath.close()
        actionForegroundColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad03(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "3"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad00(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "0"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "+"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad01(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        normalPath.fill()


        //// MainText Drawing
        let mainTextRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let mainTextTextContent = "1"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadStop(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let actionNormalColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let orange = UIColor(red: 0.957, green: 0.467, blue: 0.133, alpha: 1.000)
        var orangeHueComponent: CGFloat = 1
        var orangeSaturationComponent: CGFloat = 1
        var orangeBrightnessComponent: CGFloat = 1
        orange.getHue(&orangeHueComponent, saturation: &orangeSaturationComponent, brightness: &orangeBrightnessComponent, alpha: nil)

        let darkOrange = UIColor(hue: orangeHueComponent, saturation: orangeSaturationComponent, brightness: 0.5, alpha: orange.cgColor.alpha)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let actionPressedColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let phoneFill = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)

        //// Variable Declarations
        let keyPadStopActionBackgroundColor = pressed ? darkOrange : orange
        let keyPadStopBackgroundColor = enabled ? keyPadStopActionBackgroundColor : disabledLightGray
        let actionForegroundColor = enabled ? (pressed ? actionPressedColor : actionNormalColor) : gray
        let phoneForegroundColor = enabled ? phoneFill : actionForegroundColor

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadStopBackgroundColor.setFill()
        normalPath.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 24.52, y: 44.36))
        bezierPath.addCurve(to: CGPoint(x: 24.56, y: 44.33), controlPoint1: CGPoint(x: 24.53, y: 44.35), controlPoint2: CGPoint(x: 24.55, y: 44.34))
        bezierPath.addCurve(to: CGPoint(x: 50, y: 38.12), controlPoint1: CGPoint(x: 30.04, y: 39.19), controlPoint2: CGPoint(x: 41.42, y: 38.11))
        bezierPath.addCurve(to: CGPoint(x: 75.43, y: 44.31), controlPoint1: CGPoint(x: 58.59, y: 38.11), controlPoint2: CGPoint(x: 69.97, y: 39.19))
        bezierPath.addCurve(to: CGPoint(x: 76.08, y: 54.05), controlPoint1: CGPoint(x: 77.34, y: 46.11), controlPoint2: CGPoint(x: 76.09, y: 53.97))
        bezierPath.addCurve(to: CGPoint(x: 72.83, y: 56.86), controlPoint1: CGPoint(x: 75.72, y: 56.05), controlPoint2: CGPoint(x: 74.11, y: 57.07))
        bezierPath.addCurve(to: CGPoint(x: 62.3, y: 54.73), controlPoint1: CGPoint(x: 71.96, y: 56.72), controlPoint2: CGPoint(x: 63.27, y: 54.94))
        bezierPath.addCurve(to: CGPoint(x: 60.01, y: 52.12), controlPoint1: CGPoint(x: 61.3, y: 54.5), controlPoint2: CGPoint(x: 60.44, y: 53.52))
        bezierPath.addCurve(to: CGPoint(x: 58.78, y: 47.74), controlPoint1: CGPoint(x: 59.76, y: 51.34), controlPoint2: CGPoint(x: 59.09, y: 48.89))
        bezierPath.addCurve(to: CGPoint(x: 50.01, y: 47.17), controlPoint1: CGPoint(x: 57.69, y: 47.55), controlPoint2: CGPoint(x: 54.92, y: 47.17))
        bezierPath.addCurve(to: CGPoint(x: 41.23, y: 47.74), controlPoint1: CGPoint(x: 45.09, y: 47.17), controlPoint2: CGPoint(x: 42.32, y: 47.55))
        bezierPath.addCurve(to: CGPoint(x: 40, y: 52.12), controlPoint1: CGPoint(x: 40.92, y: 48.89), controlPoint2: CGPoint(x: 40.25, y: 51.34))
        bezierPath.addCurve(to: CGPoint(x: 37.72, y: 54.72), controlPoint1: CGPoint(x: 39.58, y: 53.5), controlPoint2: CGPoint(x: 38.73, y: 54.48))
        bezierPath.addCurve(to: CGPoint(x: 27.2, y: 56.86), controlPoint1: CGPoint(x: 36.7, y: 54.96), controlPoint2: CGPoint(x: 28.01, y: 56.71))
        bezierPath.addCurve(to: CGPoint(x: 25.14, y: 56.24), controlPoint1: CGPoint(x: 26.51, y: 56.98), controlPoint2: CGPoint(x: 25.76, y: 56.75))
        bezierPath.addCurve(to: CGPoint(x: 23.93, y: 54.04), controlPoint1: CGPoint(x: 24.52, y: 55.71), controlPoint2: CGPoint(x: 24.09, y: 54.93))
        bezierPath.addCurve(to: CGPoint(x: 24.52, y: 44.36), controlPoint1: CGPoint(x: 23.92, y: 53.96), controlPoint2: CGPoint(x: 22.68, y: 46.2))
        bezierPath.close()
        phoneForegroundColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad05(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "5"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "JKL"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadHash2(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "#"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad04(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "4"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad09(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "9"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "WXYZ"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad04(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "4"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "GHI"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadHash(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "#"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad02(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "2"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "ABC"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadGo(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let actionNormalColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let actionPressedColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let green = UIColor(red: 0.055, green: 0.722, blue: 0.604, alpha: 1.000)
        var greenHueComponent: CGFloat = 1
        var greenSaturationComponent: CGFloat = 1
        var greenBrightnessComponent: CGFloat = 1
        green.getHue(&greenHueComponent, saturation: &greenSaturationComponent, brightness: &greenBrightnessComponent, alpha: nil)

        let darkGreen = UIColor(hue: greenHueComponent, saturation: greenSaturationComponent, brightness: 0.5, alpha: green.cgColor.alpha)
        let phoneFill = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)

        //// Variable Declarations
        let keyPadGoActionBackgroundColor = pressed ? darkGreen : green
        let keyPadGoBackgroundColor = enabled ? keyPadGoActionBackgroundColor : disabledLightGray
        let actionForegroundColor = enabled ? (pressed ? actionPressedColor : actionNormalColor) : gray
        let phoneForegroundColor = enabled ? phoneFill : actionForegroundColor

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadGoBackgroundColor.setFill()
        normalPath.fill()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 64.03, y: 72))
        bezierPath.addCurve(to: CGPoint(x: 63.98, y: 72), controlPoint1: CGPoint(x: 64.01, y: 72), controlPoint2: CGPoint(x: 64, y: 72))
        bezierPath.addCurve(to: CGPoint(x: 41.59, y: 58.4), controlPoint1: CGPoint(x: 56.47, y: 71.76), controlPoint2: CGPoint(x: 47.66, y: 64.47))
        bezierPath.addCurve(to: CGPoint(x: 28, y: 36.04), controlPoint1: CGPoint(x: 35.52, y: 52.33), controlPoint2: CGPoint(x: 28.24, y: 43.52))
        bezierPath.addCurve(to: CGPoint(x: 34.42, y: 28.7), controlPoint1: CGPoint(x: 27.91, y: 33.42), controlPoint2: CGPoint(x: 34.36, y: 28.75))
        bezierPath.addCurve(to: CGPoint(x: 38.71, y: 29.01), controlPoint1: CGPoint(x: 36.09, y: 27.54), controlPoint2: CGPoint(x: 37.95, y: 27.95))
        bezierPath.addCurve(to: CGPoint(x: 44.64, y: 37.96), controlPoint1: CGPoint(x: 39.23, y: 29.72), controlPoint2: CGPoint(x: 44.11, y: 37.12))
        bezierPath.addCurve(to: CGPoint(x: 44.42, y: 41.43), controlPoint1: CGPoint(x: 45.19, y: 38.83), controlPoint2: CGPoint(x: 45.11, y: 40.13))
        bezierPath.addCurve(to: CGPoint(x: 42.2, y: 45.39), controlPoint1: CGPoint(x: 44.04, y: 42.15), controlPoint2: CGPoint(x: 42.79, y: 44.36))
        bezierPath.addCurve(to: CGPoint(x: 47.99, y: 52), controlPoint1: CGPoint(x: 42.83, y: 46.3), controlPoint2: CGPoint(x: 44.52, y: 48.52))
        bezierPath.addCurve(to: CGPoint(x: 54.6, y: 57.8), controlPoint1: CGPoint(x: 51.47, y: 55.47), controlPoint2: CGPoint(x: 53.69, y: 57.16))
        bezierPath.addCurve(to: CGPoint(x: 58.57, y: 55.57), controlPoint1: CGPoint(x: 55.63, y: 57.21), controlPoint2: CGPoint(x: 57.84, y: 55.95))
        bezierPath.addCurve(to: CGPoint(x: 62.02, y: 55.35), controlPoint1: CGPoint(x: 59.85, y: 54.89), controlPoint2: CGPoint(x: 61.14, y: 54.81))
        bezierPath.addCurve(to: CGPoint(x: 70.97, y: 61.28), controlPoint1: CGPoint(x: 62.91, y: 55.9), controlPoint2: CGPoint(x: 70.29, y: 60.8))
        bezierPath.addCurve(to: CGPoint(x: 71.99, y: 63.17), controlPoint1: CGPoint(x: 71.54, y: 61.68), controlPoint2: CGPoint(x: 71.91, y: 62.37))
        bezierPath.addCurve(to: CGPoint(x: 71.29, y: 65.58), controlPoint1: CGPoint(x: 72.06, y: 63.97), controlPoint2: CGPoint(x: 71.81, y: 64.83))
        bezierPath.addCurve(to: CGPoint(x: 64.03, y: 72), controlPoint1: CGPoint(x: 71.24, y: 65.64), controlPoint2: CGPoint(x: 66.63, y: 72))
        bezierPath.close()
        phoneForegroundColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad06(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "6"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad01(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        normalPath.fill()


        //// MainText Drawing
        let mainTextRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let mainTextTextContent = "1"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPad08(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 67)
        let textTextContent = "8"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 5, y: 60, width: 90, height: 21)
        let text2TextContent = "TUV"
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadMute(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let actionNormalColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let actionPressedColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let actionForegroundColor = enabled ? (pressed ? actionPressedColor : actionNormalColor) : gray

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        normalPath.fill()


        //// Group
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 25, y: 25))
        bezierPath.addLine(to: CGPoint(x: 75, y: 75))
        actionForegroundColor.setStroke()
        bezierPath.lineWidth = 6
        bezierPath.lineCapStyle = .round
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 35.52, y: 42.29))
        bezier2Path.addCurve(to: CGPoint(x: 35.88, y: 43), controlPoint1: CGPoint(x: 35.78, y: 42.54), controlPoint2: CGPoint(x: 35.88, y: 42.76))
        bezier2Path.addLine(to: CGPoint(x: 35.88, y: 48))
        bezier2Path.addCurve(to: CGPoint(x: 50, y: 62.13), controlPoint1: CGPoint(x: 35.88, y: 55.8), controlPoint2: CGPoint(x: 42.2, y: 62.13))
        bezier2Path.addCurve(to: CGPoint(x: 55.4, y: 61.06), controlPoint1: CGPoint(x: 51.91, y: 62.13), controlPoint2: CGPoint(x: 53.74, y: 61.74))
        bezier2Path.addCurve(to: CGPoint(x: 56.72, y: 62.38), controlPoint1: CGPoint(x: 55.84, y: 61.5), controlPoint2: CGPoint(x: 56.29, y: 61.94))
        bezier2Path.addCurve(to: CGPoint(x: 53, y: 63.59), controlPoint1: CGPoint(x: 55.55, y: 62.93), controlPoint2: CGPoint(x: 54.3, y: 63.34))
        bezier2Path.addLine(to: CGPoint(x: 53, y: 69))
        bezier2Path.addLine(to: CGPoint(x: 47, y: 69))
        bezier2Path.addLine(to: CGPoint(x: 47, y: 63.59))
        bezier2Path.addCurve(to: CGPoint(x: 34.12, y: 48), controlPoint1: CGPoint(x: 39.69, y: 62.18), controlPoint2: CGPoint(x: 34.12, y: 55.71))
        bezier2Path.addLine(to: CGPoint(x: 34.12, y: 43))
        bezier2Path.addCurve(to: CGPoint(x: 34.81, y: 42.13), controlPoint1: CGPoint(x: 34.11, y: 42.58), controlPoint2: CGPoint(x: 34.4, y: 42.21))
        bezier2Path.addLine(to: CGPoint(x: 34.91, y: 42.13))
        bezier2Path.addCurve(to: CGPoint(x: 35.55, y: 42.31), controlPoint1: CGPoint(x: 35.14, y: 42.1), controlPoint2: CGPoint(x: 35.37, y: 42.17))
        bezier2Path.addLine(to: CGPoint(x: 35.52, y: 42.29))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: 61, y: 35.72))
        bezier2Path.addLine(to: CGPoint(x: 61, y: 48.28))
        bezier2Path.addCurve(to: CGPoint(x: 59.44, y: 53.79), controlPoint1: CGPoint(x: 61, y: 50.3), controlPoint2: CGPoint(x: 60.43, y: 52.18))
        bezier2Path.addCurve(to: CGPoint(x: 39.22, y: 33.56), controlPoint1: CGPoint(x: 52.67, y: 47.01), controlPoint2: CGPoint(x: 45.2, y: 39.54))
        bezier2Path.addCurve(to: CGPoint(x: 50, y: 25), controlPoint1: CGPoint(x: 40.25, y: 28.66), controlPoint2: CGPoint(x: 44.68, y: 25))
        bezier2Path.addCurve(to: CGPoint(x: 61, y: 35.72), controlPoint1: CGPoint(x: 56.08, y: 25), controlPoint2: CGPoint(x: 61, y: 29.79))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: 65, y: 42.13))
        bezier2Path.addCurve(to: CGPoint(x: 65.88, y: 43), controlPoint1: CGPoint(x: 65.48, y: 42.13), controlPoint2: CGPoint(x: 65.88, y: 42.52))
        bezier2Path.addLine(to: CGPoint(x: 65.88, y: 48))
        bezier2Path.addCurve(to: CGPoint(x: 62.9, y: 57.24), controlPoint1: CGPoint(x: 65.88, y: 51.44), controlPoint2: CGPoint(x: 64.77, y: 54.63))
        bezier2Path.addCurve(to: CGPoint(x: 61.65, y: 55.99), controlPoint1: CGPoint(x: 62.48, y: 56.83), controlPoint2: CGPoint(x: 62.07, y: 56.41))
        bezier2Path.addCurve(to: CGPoint(x: 64.12, y: 48), controlPoint1: CGPoint(x: 63.21, y: 53.72), controlPoint2: CGPoint(x: 64.12, y: 50.97))
        bezier2Path.addLine(to: CGPoint(x: 64.12, y: 43))
        bezier2Path.addCurve(to: CGPoint(x: 65, y: 42.13), controlPoint1: CGPoint(x: 64.12, y: 42.52), controlPoint2: CGPoint(x: 64.52, y: 42.13))
        bezier2Path.addLine(to: CGPoint(x: 65, y: 42.13))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: 52.95, y: 58.61))
        bezier2Path.addCurve(to: CGPoint(x: 50, y: 59), controlPoint1: CGPoint(x: 52.01, y: 58.86), controlPoint2: CGPoint(x: 51.02, y: 59))
        bezier2Path.addCurve(to: CGPoint(x: 39, y: 48.28), controlPoint1: CGPoint(x: 43.92, y: 59), controlPoint2: CGPoint(x: 39, y: 54.21))
        bezier2Path.addCurve(to: CGPoint(x: 39, y: 44.66), controlPoint1: CGPoint(x: 39, y: 48.28), controlPoint2: CGPoint(x: 39, y: 46.7))
        bezier2Path.addCurve(to: CGPoint(x: 52.95, y: 58.61), controlPoint1: CGPoint(x: 43.48, y: 49.14), controlPoint2: CGPoint(x: 48.36, y: 54.01))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: 62.91, y: 74.47))
        bezier2Path.addLine(to: CGPoint(x: 62.88, y: 74.94))
        bezier2Path.addLine(to: CGPoint(x: 37, y: 75))
        bezier2Path.addLine(to: CGPoint(x: 37.03, y: 74.47))
        bezier2Path.addCurve(to: CGPoint(x: 40.5, y: 71), controlPoint1: CGPoint(x: 37.03, y: 72.56), controlPoint2: CGPoint(x: 38.59, y: 71))
        bezier2Path.addLine(to: CGPoint(x: 59.44, y: 71))
        bezier2Path.addCurve(to: CGPoint(x: 62.91, y: 74.47), controlPoint1: CGPoint(x: 61.35, y: 71), controlPoint2: CGPoint(x: 62.91, y: 72.56))
        bezier2Path.close()
        actionForegroundColor.setFill()
        bezier2Path.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad09(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "9"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadStar(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 49, y: 33))
        bezier2Path.addLine(to: CGPoint(x: 51, y: 33))
        bezier2Path.addLine(to: CGPoint(x: 51, y: 46.5))
        bezier2Path.addCurve(to: CGPoint(x: 51.5, y: 47.37), controlPoint1: CGPoint(x: 51, y: 46.86), controlPoint2: CGPoint(x: 51.19, y: 47.19))
        bezier2Path.addCurve(to: CGPoint(x: 52.5, y: 47.38), controlPoint1: CGPoint(x: 51.8, y: 47.55), controlPoint2: CGPoint(x: 52.19, y: 47.55))
        bezier2Path.addLine(to: CGPoint(x: 64.25, y: 40.66))
        bezier2Path.addLine(to: CGPoint(x: 65.25, y: 42.34))
        bezier2Path.addLine(to: CGPoint(x: 53.5, y: 49.12))
        bezier2Path.addCurve(to: CGPoint(x: 52.98, y: 50), controlPoint1: CGPoint(x: 53.18, y: 49.3), controlPoint2: CGPoint(x: 52.98, y: 49.64))
        bezier2Path.addCurve(to: CGPoint(x: 53.5, y: 50.88), controlPoint1: CGPoint(x: 52.98, y: 50.36), controlPoint2: CGPoint(x: 53.18, y: 50.7))
        bezier2Path.addLine(to: CGPoint(x: 65.25, y: 57.66))
        bezier2Path.addLine(to: CGPoint(x: 64.25, y: 59.34))
        bezier2Path.addLine(to: CGPoint(x: 52.5, y: 52.62))
        bezier2Path.addCurve(to: CGPoint(x: 51.5, y: 52.63), controlPoint1: CGPoint(x: 52.19, y: 52.45), controlPoint2: CGPoint(x: 51.8, y: 52.45))
        bezier2Path.addCurve(to: CGPoint(x: 51, y: 53.5), controlPoint1: CGPoint(x: 51.19, y: 52.81), controlPoint2: CGPoint(x: 51, y: 53.14))
        bezier2Path.addLine(to: CGPoint(x: 51, y: 67))
        bezier2Path.addLine(to: CGPoint(x: 49, y: 67))
        bezier2Path.addLine(to: CGPoint(x: 49, y: 53.5))
        bezier2Path.addCurve(to: CGPoint(x: 48.5, y: 52.63), controlPoint1: CGPoint(x: 49, y: 53.14), controlPoint2: CGPoint(x: 48.81, y: 52.81))
        bezier2Path.addCurve(to: CGPoint(x: 47.5, y: 52.62), controlPoint1: CGPoint(x: 48.2, y: 52.45), controlPoint2: CGPoint(x: 47.81, y: 52.45))
        bezier2Path.addLine(to: CGPoint(x: 35.75, y: 59.34))
        bezier2Path.addLine(to: CGPoint(x: 34.75, y: 57.66))
        bezier2Path.addLine(to: CGPoint(x: 46.5, y: 50.88))
        bezier2Path.addCurve(to: CGPoint(x: 47.02, y: 50), controlPoint1: CGPoint(x: 46.82, y: 50.7), controlPoint2: CGPoint(x: 47.02, y: 50.36))
        bezier2Path.addCurve(to: CGPoint(x: 46.5, y: 49.12), controlPoint1: CGPoint(x: 47.02, y: 49.64), controlPoint2: CGPoint(x: 46.82, y: 49.3))
        bezier2Path.addLine(to: CGPoint(x: 34.75, y: 42.34))
        bezier2Path.addLine(to: CGPoint(x: 35.75, y: 40.66))
        bezier2Path.addLine(to: CGPoint(x: 47.5, y: 47.38))
        bezier2Path.addCurve(to: CGPoint(x: 48.5, y: 47.37), controlPoint1: CGPoint(x: 47.81, y: 47.55), controlPoint2: CGPoint(x: 48.2, y: 47.55))
        bezier2Path.addCurve(to: CGPoint(x: 49, y: 46.5), controlPoint1: CGPoint(x: 48.81, y: 47.19), controlPoint2: CGPoint(x: 49, y: 46.86))
        bezier2Path.addLine(to: CGPoint(x: 49, y: 33))
        bezier2Path.close()
        textForegroundColor.setFill()
        bezier2Path.fill()
        textForegroundColor.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.miterLimit = 4
        bezier2Path.lineCapStyle = .round
        bezier2Path.lineJoinStyle = .round
        bezier2Path.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad05(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "5"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad02(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "2"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad08(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "8"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadStar2(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 49, y: 33))
        bezier2Path.addLine(to: CGPoint(x: 51, y: 33))
        bezier2Path.addLine(to: CGPoint(x: 51, y: 46.5))
        bezier2Path.addCurve(to: CGPoint(x: 51.5, y: 47.37), controlPoint1: CGPoint(x: 51, y: 46.86), controlPoint2: CGPoint(x: 51.19, y: 47.19))
        bezier2Path.addCurve(to: CGPoint(x: 52.5, y: 47.38), controlPoint1: CGPoint(x: 51.8, y: 47.55), controlPoint2: CGPoint(x: 52.19, y: 47.55))
        bezier2Path.addLine(to: CGPoint(x: 64.25, y: 40.66))
        bezier2Path.addLine(to: CGPoint(x: 65.25, y: 42.34))
        bezier2Path.addLine(to: CGPoint(x: 53.5, y: 49.12))
        bezier2Path.addCurve(to: CGPoint(x: 52.98, y: 50), controlPoint1: CGPoint(x: 53.18, y: 49.3), controlPoint2: CGPoint(x: 52.98, y: 49.64))
        bezier2Path.addCurve(to: CGPoint(x: 53.5, y: 50.88), controlPoint1: CGPoint(x: 52.98, y: 50.36), controlPoint2: CGPoint(x: 53.18, y: 50.7))
        bezier2Path.addLine(to: CGPoint(x: 65.25, y: 57.66))
        bezier2Path.addLine(to: CGPoint(x: 64.25, y: 59.34))
        bezier2Path.addLine(to: CGPoint(x: 52.5, y: 52.62))
        bezier2Path.addCurve(to: CGPoint(x: 51.5, y: 52.63), controlPoint1: CGPoint(x: 52.19, y: 52.45), controlPoint2: CGPoint(x: 51.8, y: 52.45))
        bezier2Path.addCurve(to: CGPoint(x: 51, y: 53.5), controlPoint1: CGPoint(x: 51.19, y: 52.81), controlPoint2: CGPoint(x: 51, y: 53.14))
        bezier2Path.addLine(to: CGPoint(x: 51, y: 67))
        bezier2Path.addLine(to: CGPoint(x: 49, y: 67))
        bezier2Path.addLine(to: CGPoint(x: 49, y: 53.5))
        bezier2Path.addCurve(to: CGPoint(x: 48.5, y: 52.63), controlPoint1: CGPoint(x: 49, y: 53.14), controlPoint2: CGPoint(x: 48.81, y: 52.81))
        bezier2Path.addCurve(to: CGPoint(x: 47.5, y: 52.62), controlPoint1: CGPoint(x: 48.2, y: 52.45), controlPoint2: CGPoint(x: 47.81, y: 52.45))
        bezier2Path.addLine(to: CGPoint(x: 35.75, y: 59.34))
        bezier2Path.addLine(to: CGPoint(x: 34.75, y: 57.66))
        bezier2Path.addLine(to: CGPoint(x: 46.5, y: 50.88))
        bezier2Path.addCurve(to: CGPoint(x: 47.02, y: 50), controlPoint1: CGPoint(x: 46.82, y: 50.7), controlPoint2: CGPoint(x: 47.02, y: 50.36))
        bezier2Path.addCurve(to: CGPoint(x: 46.5, y: 49.12), controlPoint1: CGPoint(x: 47.02, y: 49.64), controlPoint2: CGPoint(x: 46.82, y: 49.3))
        bezier2Path.addLine(to: CGPoint(x: 34.75, y: 42.34))
        bezier2Path.addLine(to: CGPoint(x: 35.75, y: 40.66))
        bezier2Path.addLine(to: CGPoint(x: 47.5, y: 47.38))
        bezier2Path.addCurve(to: CGPoint(x: 48.5, y: 47.37), controlPoint1: CGPoint(x: 47.81, y: 47.55), controlPoint2: CGPoint(x: 48.2, y: 47.55))
        bezier2Path.addCurve(to: CGPoint(x: 49, y: 46.5), controlPoint1: CGPoint(x: 48.81, y: 47.19), controlPoint2: CGPoint(x: 49, y: 46.86))
        bezier2Path.addLine(to: CGPoint(x: 49, y: 33))
        bezier2Path.close()
        textForegroundColor.setFill()
        bezier2Path.fill()
        textForegroundColor.setStroke()
        bezier2Path.lineWidth = 2
        bezier2Path.miterLimit = 4
        bezier2Path.lineCapStyle = .round
        bezier2Path.lineJoinStyle = .round
        bezier2Path.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawNumPad00(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let textColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let textForegroundColor = enabled ? textColor : gray

        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        ovalPath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 5, y: 5, width: 90, height: 90)
        let textTextContent = "0"
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 48),
            .foregroundColor: textForegroundColor,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = textTextContent.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        textTextContent.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawKeyPadNumPad(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit, pressed: Bool = false, enabled: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let actionNormalColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let gray = UIColor(red: 0.820, green: 0.824, blue: 0.831, alpha: 1.000)
        let actionPressedColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let lightGray = UIColor(red: 0.914, green: 0.918, blue: 0.922, alpha: 1.000)
        let disabledLightGray = lightGray.withAlphaComponent(0.3)
        let darkGray = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)

        //// Variable Declarations
        let keyPadActionBackgroundColor = pressed ? darkGray : gray
        let keyPadBackroundColor = enabled ? keyPadActionBackgroundColor : disabledLightGray
        let actionForegroundColor = enabled ? (pressed ? actionPressedColor : actionNormalColor) : gray

        //// Normal Drawing
        let normalPath = UIBezierPath(ovalIn: CGRect(x: 5, y: 5, width: 90, height: 90))
        keyPadBackroundColor.setFill()
        normalPath.fill()


        //// Group 4
        //// Group 3
        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 41.5, y: 41.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        ovalPath.fill()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: 41.5, y: 22.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval2Path.fill()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: 41.5, y: 60.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval3Path.fill()




        //// Group
        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: 60.5, y: 41.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval4Path.fill()


        //// Oval 5 Drawing
        let oval5Path = UIBezierPath(ovalIn: CGRect(x: 60.5, y: 22.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval5Path.fill()


        //// Oval 6 Drawing
        let oval6Path = UIBezierPath(ovalIn: CGRect(x: 60.5, y: 60.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval6Path.fill()




        //// Group 2
        //// Oval 7 Drawing
        let oval7Path = UIBezierPath(ovalIn: CGRect(x: 22.5, y: 41.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval7Path.fill()


        //// Oval 8 Drawing
        let oval8Path = UIBezierPath(ovalIn: CGRect(x: 22.5, y: 22.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval8Path.fill()


        //// Oval 9 Drawing
        let oval9Path = UIBezierPath(ovalIn: CGRect(x: 22.5, y: 60.5, width: 17, height: 17))
        actionForegroundColor.setFill()
        oval9Path.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawRSSIProgressBar(minUsableProgress: CGFloat = 0.25, minRegistrationProgress: CGFloat = 0.368, width: CGFloat = 300, radius: CGFloat = 5, rightToLeft: Bool = false, rssiValue: CGFloat = -92) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let moderateSignal = UIColor(red: 0.943, green: 0.957, blue: 0.133, alpha: 1.000)
        let trackFillColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let textColor2 = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)
        let trackLineColor = UIColor(red: 0.349, green: 0.345, blue: 0.353, alpha: 1.000)
        let lowSignal = UIColor(red: 0.957, green: 0.467, blue: 0.133, alpha: 1.000)
        let goodSignal = UIColor(red: 0.055, green: 0.722, blue: 0.604, alpha: 1.000)

        //// Variable Declarations
        let maxValue: CGFloat = -50
        let minValue: CGFloat = -130
        let numericalRange: CGFloat = abs(minValue) - abs(maxValue)
        let minUsableangeNumericalValue = "\(Int(round(numericalRange * minUsableProgress + minValue)))" + "dBm"
        let minRegistrationNumericalValue = "\(Int(round(numericalRange * minRegistrationProgress + minValue)))" + "dBm"
        let maxTextXPos: CGFloat = width
        let textWidth: CGFloat = width * 0.97
        let rtlProgressTextXPos: CGFloat = width - width * 0.97
        let minUsableValue: CGFloat = rightToLeft ? width - width * minUsableProgress : width * minUsableProgress
        let leftToRight = !rightToLeft
        let minTextValue = rightToLeft ? "\(Int(round(maxValue)))" + "dB" : "\(Int(round(minValue)))" + "dBm"
        let maxTextValue = rightToLeft ? "\(Int(round(minValue)))" + "dB" : "\(Int(round(maxValue)))" + "dBm"
        let minRegistrationValue: CGFloat = rightToLeft ? width - width * minRegistrationProgress : width * minRegistrationProgress
        let progress: CGFloat = min(1, max(0, (rssiValue - minValue) / (maxValue - minValue)))
        let progressColor = progress <= 0.25 ? lowSignal : (progress <= 0.3625 ? moderateSignal : goodSignal)
        let progressWidth: CGFloat = max(5, progress * width)
        let progressXPos: CGFloat = rightToLeft ? width - progressWidth + 0.5 : 0.5
        let rssiText = "\(Int(round(rssiValue)))" + "dBm"
        let smallScreenFix = false

        //// TextLabels
        if (smallScreenFix) {
            //// TextMinUsable Drawing
            context.saveGState()
            context.translateBy(x: minUsableValue, y: 37)

            let textMinUsableRect = CGRect(x: -25, y: -7, width: 50, height: 14)
            let textMinUsableStyle = NSMutableParagraphStyle()
            textMinUsableStyle.alignment = .center
            let textMinUsableFontAttributes = [
                .font: UIFont.systemFont(ofSize: 10),
                .foregroundColor: textColor2,
                .paragraphStyle: textMinUsableStyle,
            ] as [NSAttributedString.Key: Any]

            let textMinUsableTextHeight: CGFloat = minUsableangeNumericalValue.boundingRect(with: CGSize(width: textMinUsableRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textMinUsableFontAttributes, context: nil).height
            context.saveGState()
            context.clip(to: textMinUsableRect)
            minUsableangeNumericalValue.draw(in: CGRect(x: textMinUsableRect.minX, y: textMinUsableRect.minY + (textMinUsableRect.height - textMinUsableTextHeight) / 2, width: textMinUsableRect.width, height: textMinUsableTextHeight), withAttributes: textMinUsableFontAttributes)
            context.restoreGState()

            context.restoreGState()
        }


        //// TextMinRegistration Drawing
        context.saveGState()
        context.translateBy(x: minRegistrationValue, y: 37)

        let textMinRegistrationRect = CGRect(x: -25, y: -7, width: 50, height: 14)
        let textMinRegistrationStyle = NSMutableParagraphStyle()
        textMinRegistrationStyle.alignment = .center
        let textMinRegistrationFontAttributes = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: textColor2,
            .paragraphStyle: textMinRegistrationStyle,
        ] as [NSAttributedString.Key: Any]

        let textMinRegistrationTextHeight: CGFloat = minRegistrationNumericalValue.boundingRect(with: CGSize(width: textMinRegistrationRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textMinRegistrationFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textMinRegistrationRect)
        minRegistrationNumericalValue.draw(in: CGRect(x: textMinRegistrationRect.minX, y: textMinRegistrationRect.minY + (textMinRegistrationRect.height - textMinRegistrationTextHeight) / 2, width: textMinRegistrationRect.width, height: textMinRegistrationTextHeight), withAttributes: textMinRegistrationFontAttributes)
        context.restoreGState()

        context.restoreGState()


        //// TextMin Drawing
        context.saveGState()
        context.translateBy(x: 25, y: 37)

        let textMinRect = CGRect(x: -25, y: -7, width: 50, height: 14)
        let textMinStyle = NSMutableParagraphStyle()
        textMinStyle.alignment = .left
        let textMinFontAttributes = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: textColor2,
            .paragraphStyle: textMinStyle,
        ] as [NSAttributedString.Key: Any]

        let textMinTextHeight: CGFloat = minTextValue.boundingRect(with: CGSize(width: textMinRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textMinFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textMinRect)
        minTextValue.draw(in: CGRect(x: textMinRect.minX, y: textMinRect.minY + (textMinRect.height - textMinTextHeight) / 2, width: textMinRect.width, height: textMinTextHeight), withAttributes: textMinFontAttributes)
        context.restoreGState()

        context.restoreGState()


        //// TextMax Drawing
        context.saveGState()
        context.translateBy(x: (maxTextXPos - 25), y: 38)

        let textMaxRect = CGRect(x: -25, y: -7, width: 50, height: 14)
        let textMaxStyle = NSMutableParagraphStyle()
        textMaxStyle.alignment = .right
        let textMaxFontAttributes = [
            .font: UIFont.systemFont(ofSize: 10),
            .foregroundColor: textColor2,
            .paragraphStyle: textMaxStyle,
        ] as [NSAttributedString.Key: Any]

        let textMaxTextHeight: CGFloat = maxTextValue.boundingRect(with: CGSize(width: textMaxRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textMaxFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textMaxRect)
        maxTextValue.draw(in: CGRect(x: textMaxRect.minX, y: textMaxRect.minY + (textMaxRect.height - textMaxTextHeight) / 2, width: textMaxRect.width, height: textMaxTextHeight), withAttributes: textMaxFontAttributes)
        context.restoreGState()

        context.restoreGState()




        //// TrackBackground Drawing
        let trackBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 0.5, y: 0.5, width: width, height: 28), cornerRadius: radius)
        trackFillColor.setFill()
        trackBackgroundPath.fill()


        //// ActiveProgress
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip ClipShape
        let clipShapePath = UIBezierPath(roundedRect: CGRect(x: 0.5, y: 0.5, width: width, height: 28), cornerRadius: radius)
        clipShapePath.addClip()


        //// Group
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip ProgressBar
        let progressBarPath = UIBezierPath(rect: CGRect(x: (progressXPos - 0.5), y: 0.5, width: progressWidth, height: 28))
        progressBarPath.addClip()


        //// ProgressBarFill Drawing
        let progressBarFillPath = UIBezierPath(rect: CGRect(x: 0.5, y: 0.5, width: width, height: 28))
        progressColor.setFill()
        progressBarFillPath.fill()


        context.endTransparencyLayer()
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// TrackForeground
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: 0.5, y: 0.5, width: width, height: 28), cornerRadius: radius)
        trackLineColor.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        if (rightToLeft) {
            //// RightToLeftTextLabel Drawing
            let rightToLeftTextLabelRect = CGRect(x: rtlProgressTextXPos, y: 4, width: textWidth, height: 21)
            let rightToLeftTextLabelStyle = NSMutableParagraphStyle()
            rightToLeftTextLabelStyle.alignment = .left
            let rightToLeftTextLabelFontAttributes = [
                .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
                .foregroundColor: textColor2,
                .paragraphStyle: rightToLeftTextLabelStyle,
            ] as [NSAttributedString.Key: Any]

            let rightToLeftTextLabelTextHeight: CGFloat = rssiText.boundingRect(with: CGSize(width: rightToLeftTextLabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: rightToLeftTextLabelFontAttributes, context: nil).height
            context.saveGState()
            context.clip(to: rightToLeftTextLabelRect)
            rssiText.draw(in: CGRect(x: rightToLeftTextLabelRect.minX, y: rightToLeftTextLabelRect.minY + (rightToLeftTextLabelRect.height - rightToLeftTextLabelTextHeight) / 2, width: rightToLeftTextLabelRect.width, height: rightToLeftTextLabelTextHeight), withAttributes: rightToLeftTextLabelFontAttributes)
            context.restoreGState()
        }


        if (leftToRight) {
            //// LeftToRightTextLabel Drawing
            let leftToRightTextLabelRect = CGRect(x: 0.5, y: 4.5, width: textWidth, height: 21)
            let leftToRightTextLabelStyle = NSMutableParagraphStyle()
            leftToRightTextLabelStyle.alignment = .right
            let leftToRightTextLabelFontAttributes = [
                .font: UIFont.systemFont(ofSize: UIFont.labelFontSize),
                .foregroundColor: textColor2,
                .paragraphStyle: leftToRightTextLabelStyle,
            ] as [NSAttributedString.Key: Any]

            let leftToRightTextLabelTextHeight: CGFloat = rssiText.boundingRect(with: CGSize(width: leftToRightTextLabelRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: leftToRightTextLabelFontAttributes, context: nil).height
            context.saveGState()
            context.clip(to: leftToRightTextLabelRect)
            rssiText.draw(in: CGRect(x: leftToRightTextLabelRect.minX, y: leftToRightTextLabelRect.minY + (leftToRightTextLabelRect.height - leftToRightTextLabelTextHeight) / 2, width: leftToRightTextLabelRect.width, height: leftToRightTextLabelTextHeight), withAttributes: leftToRightTextLabelFontAttributes)
            context.restoreGState()
        }


        //// HighRange Drawing
        context.saveGState()
        context.translateBy(x: (minRegistrationValue - 0.75), y: 0.5)

        let highRangePath = UIBezierPath()
        highRangePath.move(to: CGPoint(x: 0, y: 0))
        highRangePath.addCurve(to: CGPoint(x: 0, y: 28), controlPoint1: CGPoint(x: 0, y: 28), controlPoint2: CGPoint(x: 0, y: 28))
        trackLineColor.setStroke()
        highRangePath.lineWidth = 1
        highRangePath.stroke()

        context.restoreGState()


        //// LowRange Drawing
        context.saveGState()
        context.translateBy(x: (minUsableValue - 0.5), y: 0.5)

        let lowRangePath = UIBezierPath()
        lowRangePath.move(to: CGPoint(x: 0, y: 0))
        lowRangePath.addLine(to: CGPoint(x: 0, y: 28))
        trackLineColor.setStroke()
        lowRangePath.lineWidth = 1
        lowRangePath.stroke()

        context.restoreGState()
    }

    @objc dynamic public class func drawLogoLoader(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 300, height: 300), resizing: ResizingBehavior = .aspectFit, cycleProgress: CGFloat = 0) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 300, height: 300), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 300, y: resizedFrame.height / 300)


        //// Color Declarations
        let yellow = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        var yellowRedComponent: CGFloat = 1
        var yellowGreenComponent: CGFloat = 1
        var yellowBlueComponent: CGFloat = 1
        yellow.getRed(&yellowRedComponent, green: &yellowGreenComponent, blue: &yellowBlueComponent, alpha: nil)

        let yellowDark12 = UIColor(red: (yellowRedComponent * 0.88), green: (yellowGreenComponent * 0.88), blue: (yellowBlueComponent * 0.88), alpha: (yellow.cgColor.alpha * 0.88 + 0.12))
        let yellowDark38 = UIColor(red: (yellowRedComponent * 0.62), green: (yellowGreenComponent * 0.62), blue: (yellowBlueComponent * 0.62), alpha: (yellow.cgColor.alpha * 0.62 + 0.38))
        let yellowDark50 = UIColor(red: (yellowRedComponent * 0.5), green: (yellowGreenComponent * 0.5), blue: (yellowBlueComponent * 0.5), alpha: (yellow.cgColor.alpha * 0.5 + 0.5))
        let yellowDark25 = UIColor(red: (yellowRedComponent * 0.75), green: (yellowGreenComponent * 0.75), blue: (yellowBlueComponent * 0.75), alpha: (yellow.cgColor.alpha * 0.75 + 0.25))
        let appleGrey = UIColor(red: 0.451, green: 0.451, blue: 0.451, alpha: 1.000)

        //// Variable Declarations
        let cycleAngle: CGFloat = 360.0 / 16.0 * round(16 * -cycleProgress)

        //// Dots
        context.saveGState()
        context.translateBy(x: 150, y: 150)
        context.rotate(by: -cycleAngle * CGFloat.pi/180)



        //// Dots01
        context.saveGState()



        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: -10, y: -140, width: 20, height: 20))
        yellow.setFill()
        ovalPath.fill()


        //// Oval 2 Drawing
        let oval2Path = UIBezierPath(ovalIn: CGRect(x: -10, y: 120, width: 20, height: 20))
        yellowDark50.setFill()
        oval2Path.fill()


        //// Oval 3 Drawing
        let oval3Path = UIBezierPath(ovalIn: CGRect(x: 120, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval3Path.fill()


        //// Oval 4 Drawing
        let oval4Path = UIBezierPath(ovalIn: CGRect(x: -140, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval4Path.fill()



        context.restoreGState()


        //// Dots02
        context.saveGState()
        context.rotate(by: -22.5 * CGFloat.pi/180)



        //// Oval 5 Drawing
        let oval5Path = UIBezierPath(ovalIn: CGRect(x: -10, y: -140, width: 20, height: 20))
        yellowDark12.setFill()
        oval5Path.fill()


        //// Oval 6 Drawing
        let oval6Path = UIBezierPath(ovalIn: CGRect(x: -10, y: 120, width: 20, height: 20))
        yellowDark50.setFill()
        oval6Path.fill()


        //// Oval 7 Drawing
        let oval7Path = UIBezierPath(ovalIn: CGRect(x: 120, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval7Path.fill()


        //// Oval 8 Drawing
        let oval8Path = UIBezierPath(ovalIn: CGRect(x: -140, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval8Path.fill()



        context.restoreGState()


        //// Dots03
        context.saveGState()
        context.rotate(by: -45 * CGFloat.pi/180)



        //// Oval 9 Drawing
        let oval9Path = UIBezierPath(ovalIn: CGRect(x: -10, y: -140, width: 20, height: 20))
        yellowDark25.setFill()
        oval9Path.fill()


        //// Oval 10 Drawing
        let oval10Path = UIBezierPath(ovalIn: CGRect(x: -10, y: 120, width: 20, height: 20))
        yellowDark50.setFill()
        oval10Path.fill()


        //// Oval 11 Drawing
        let oval11Path = UIBezierPath(ovalIn: CGRect(x: 120, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval11Path.fill()


        //// Oval 12 Drawing
        let oval12Path = UIBezierPath(ovalIn: CGRect(x: -140, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval12Path.fill()



        context.restoreGState()


        //// Dots04
        context.saveGState()
        context.rotate(by: -67.5 * CGFloat.pi/180)



        //// Oval 13 Drawing
        let oval13Path = UIBezierPath(ovalIn: CGRect(x: -10, y: -140, width: 20, height: 20))
        yellowDark38.setFill()
        oval13Path.fill()


        //// Oval 14 Drawing
        let oval14Path = UIBezierPath(ovalIn: CGRect(x: -10, y: 120, width: 20, height: 20))
        yellowDark50.setFill()
        oval14Path.fill()


        //// Oval 15 Drawing
        let oval15Path = UIBezierPath(ovalIn: CGRect(x: 120, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval15Path.fill()


        //// Oval 16 Drawing
        let oval16Path = UIBezierPath(ovalIn: CGRect(x: -140, y: -10, width: 20, height: 20))
        yellowDark50.setFill()
        oval16Path.fill()



        context.restoreGState()



        context.restoreGState()


        //// surface1


        //// Group
        //// surface
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 235.53, y: 193.2))
        bezierPath.addCurve(to: CGPoint(x: 222.58, y: 215.88), controlPoint1: CGPoint(x: 230.85, y: 202.93), controlPoint2: CGPoint(x: 228.59, y: 207.29))
        bezierPath.addCurve(to: CGPoint(x: 187.59, y: 242.97), controlPoint1: CGPoint(x: 214.15, y: 227.88), controlPoint2: CGPoint(x: 202.27, y: 242.87))
        bezierPath.addCurve(to: CGPoint(x: 153.4, y: 235.12), controlPoint1: CGPoint(x: 174.52, y: 243.08), controlPoint2: CGPoint(x: 171.15, y: 234.98))
        bezierPath.addCurve(to: CGPoint(x: 118.89, y: 243), controlPoint1: CGPoint(x: 135.67, y: 235.2), controlPoint2: CGPoint(x: 131.97, y: 243.13))
        bezierPath.addCurve(to: CGPoint(x: 84.53, y: 217.38), controlPoint1: CGPoint(x: 104.19, y: 242.87), controlPoint2: CGPoint(x: 92.95, y: 229.37))
        bezierPath.addCurve(to: CGPoint(x: 73.03, y: 123.39), controlPoint1: CGPoint(x: 60.96, y: 183.77), controlPoint2: CGPoint(x: 58.47, y: 144.35))
        bezierPath.addCurve(to: CGPoint(x: 114.94, y: 99.8), controlPoint1: CGPoint(x: 83.34, y: 108.53), controlPoint2: CGPoint(x: 99.63, y: 99.8))
        bezierPath.addCurve(to: CGPoint(x: 153.21, y: 107.82), controlPoint1: CGPoint(x: 130.53, y: 99.8), controlPoint2: CGPoint(x: 140.33, y: 107.82))
        bezierPath.addCurve(to: CGPoint(x: 191.37, y: 99.78), controlPoint1: CGPoint(x: 165.72, y: 107.82), controlPoint2: CGPoint(x: 173.33, y: 99.78))
        bezierPath.addCurve(to: CGPoint(x: 229.71, y: 118.74), controlPoint1: CGPoint(x: 205, y: 99.78), controlPoint2: CGPoint(x: 219.41, y: 106.74))
        bezierPath.addCurve(to: CGPoint(x: 235.53, y: 193.2), controlPoint1: CGPoint(x: 196.01, y: 136.05), controlPoint2: CGPoint(x: 201.49, y: 181.13))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 177.67, y: 86.36))
        bezierPath.addCurve(to: CGPoint(x: 187.4, y: 56), controlPoint1: CGPoint(x: 184.23, y: 78.47), controlPoint2: CGPoint(x: 189.22, y: 67.34))
        bezierPath.addCurve(to: CGPoint(x: 156.89, y: 71.37), controlPoint1: CGPoint(x: 176.71, y: 56.68), controlPoint2: CGPoint(x: 164.2, y: 63.08))
        bezierPath.addCurve(to: CGPoint(x: 146.91, y: 100.99), controlPoint1: CGPoint(x: 150.26, y: 78.93), controlPoint2: CGPoint(x: 144.77, y: 90.14))
        bezierPath.addCurve(to: CGPoint(x: 177.67, y: 86.36), controlPoint1: CGPoint(x: 158.59, y: 101.34), controlPoint2: CGPoint(x: 170.67, y: 94.81))
        bezierPath.close()
        appleGrey.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawBatteryDischargingStatus(batteryCharge: CGFloat = 0.5) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let connectionStatusFill = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let connectionStatusRed = UIColor(red: 0.776, green: 0.000, blue: 0.000, alpha: 1.000)
        let fillColor2 = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Variable Declarations
        let batteryChargeWidth: CGFloat = 31
        let batteryChargeProgressWidth: CGFloat = batteryCharge * batteryChargeWidth
        let batteryChargeProgressColor = batteryCharge > 0.25 ? connectionStatusFill : connectionStatusRed
        let batteryChargeText = "\(Int(round(batteryCharge * 100)))" + "%"

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 35.72, y: 3.22))
        bezierPath.addLine(to: CGPoint(x: 3.25, y: 3.22))
        bezierPath.addLine(to: CGPoint(x: 3.25, y: 18.78))
        bezierPath.addLine(to: CGPoint(x: 35.72, y: 18.78))
        bezierPath.addLine(to: CGPoint(x: 35.72, y: 3.22))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 38.96, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 38.96, y: 22), controlPoint1: CGPoint(x: 38.96, y: 0), controlPoint2: CGPoint(x: 38.96, y: 22))
        bezierPath.addLine(to: CGPoint(x: 0, y: 22))
        bezierPath.addLine(to: CGPoint(x: 0, y: 0))
        bezierPath.addLine(to: CGPoint(x: 38.96, y: 0))
        bezierPath.addLine(to: CGPoint(x: 38.96, y: 0))
        bezierPath.close()
        connectionStatusFill.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 44.55, y: 6.04))
        bezier2Path.addLine(to: CGPoint(x: 44.63, y: 6.06))
        bezier2Path.addCurve(to: CGPoint(x: 45.84, y: 7.26), controlPoint1: CGPoint(x: 45.19, y: 6.27), controlPoint2: CGPoint(x: 45.63, y: 6.7))
        bezier2Path.addCurve(to: CGPoint(x: 46, y: 9.18), controlPoint1: CGPoint(x: 46, y: 7.77), controlPoint2: CGPoint(x: 46, y: 8.24))
        bezier2Path.addLine(to: CGPoint(x: 46, y: 12.82))
        bezier2Path.addCurve(to: CGPoint(x: 45.86, y: 14.66), controlPoint1: CGPoint(x: 46, y: 13.76), controlPoint2: CGPoint(x: 46, y: 14.23))
        bezier2Path.addLine(to: CGPoint(x: 45.84, y: 14.74))
        bezier2Path.addCurve(to: CGPoint(x: 44.63, y: 15.94), controlPoint1: CGPoint(x: 45.63, y: 15.3), controlPoint2: CGPoint(x: 45.19, y: 15.73))
        bezier2Path.addCurve(to: CGPoint(x: 42.69, y: 16.1), controlPoint1: CGPoint(x: 44.12, y: 16.1), controlPoint2: CGPoint(x: 43.64, y: 16.1))
        bezier2Path.addLine(to: CGPoint(x: 41.13, y: 16.1))
        bezier2Path.addCurve(to: CGPoint(x: 41.13, y: 5.9), controlPoint1: CGPoint(x: 41.13, y: 13.43), controlPoint2: CGPoint(x: 41.13, y: 8.16))
        bezier2Path.addLine(to: CGPoint(x: 42.69, y: 5.9))
        bezier2Path.addCurve(to: CGPoint(x: 44.55, y: 6.04), controlPoint1: CGPoint(x: 43.64, y: 5.9), controlPoint2: CGPoint(x: 44.12, y: 5.9))
        bezier2Path.close()
        connectionStatusFill.setFill()
        bezier2Path.fill()


        //// Group
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 4, y: 4, width: batteryChargeProgressWidth, height: 14))
        batteryChargeProgressColor.setFill()
        rectanglePath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 4, y: 5, width: 31, height: 12)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: connectionStatusFill,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = batteryChargeText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        batteryChargeText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()




        //// Group 2
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip Rectangle 2
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 4, y: 4, width: batteryChargeProgressWidth, height: 14))
        rectangle2Path.addClip()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 4, y: 5, width: 31, height: 12)
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: fillColor2,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = batteryChargeText.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        batteryChargeText.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc dynamic public class func drawBatteryChargingStatus(batteryCharge: CGFloat = 0.5) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let connectionStatusFill = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let connectionStatusRed = UIColor(red: 0.776, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Variable Declarations
        let batteryChargeWidth: CGFloat = 31
        let batteryChargeProgressWidth: CGFloat = batteryCharge * batteryChargeWidth
        let batteryChargeInverseWidth: CGFloat = max(1, batteryChargeWidth - batteryChargeProgressWidth)
        let batteryChargeProgressColor = batteryCharge > 0.25 ? connectionStatusFill : connectionStatusRed
        let batteryChargeInverseVisible = batteryCharge != 1

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 35.72, y: 3.22))
        bezierPath.addLine(to: CGPoint(x: 3.25, y: 3.22))
        bezierPath.addLine(to: CGPoint(x: 3.25, y: 18.78))
        bezierPath.addLine(to: CGPoint(x: 35.72, y: 18.78))
        bezierPath.addLine(to: CGPoint(x: 35.72, y: 3.22))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 38.96, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 38.96, y: 22), controlPoint1: CGPoint(x: 38.96, y: 0), controlPoint2: CGPoint(x: 38.96, y: 22))
        bezierPath.addLine(to: CGPoint(x: 0, y: 22))
        bezierPath.addLine(to: CGPoint(x: 0, y: 0))
        bezierPath.addLine(to: CGPoint(x: 38.96, y: 0))
        bezierPath.addLine(to: CGPoint(x: 38.96, y: 0))
        bezierPath.close()
        connectionStatusFill.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 44.55, y: 6.04))
        bezier2Path.addLine(to: CGPoint(x: 44.63, y: 6.06))
        bezier2Path.addCurve(to: CGPoint(x: 45.84, y: 7.26), controlPoint1: CGPoint(x: 45.19, y: 6.27), controlPoint2: CGPoint(x: 45.63, y: 6.7))
        bezier2Path.addCurve(to: CGPoint(x: 46, y: 9.18), controlPoint1: CGPoint(x: 46, y: 7.77), controlPoint2: CGPoint(x: 46, y: 8.24))
        bezier2Path.addLine(to: CGPoint(x: 46, y: 12.82))
        bezier2Path.addCurve(to: CGPoint(x: 45.86, y: 14.66), controlPoint1: CGPoint(x: 46, y: 13.76), controlPoint2: CGPoint(x: 46, y: 14.23))
        bezier2Path.addLine(to: CGPoint(x: 45.84, y: 14.74))
        bezier2Path.addCurve(to: CGPoint(x: 44.63, y: 15.94), controlPoint1: CGPoint(x: 45.63, y: 15.3), controlPoint2: CGPoint(x: 45.19, y: 15.73))
        bezier2Path.addCurve(to: CGPoint(x: 42.69, y: 16.1), controlPoint1: CGPoint(x: 44.12, y: 16.1), controlPoint2: CGPoint(x: 43.64, y: 16.1))
        bezier2Path.addLine(to: CGPoint(x: 41.13, y: 16.1))
        bezier2Path.addCurve(to: CGPoint(x: 41.13, y: 5.9), controlPoint1: CGPoint(x: 41.13, y: 13.43), controlPoint2: CGPoint(x: 41.13, y: 8.16))
        bezier2Path.addLine(to: CGPoint(x: 42.69, y: 5.9))
        bezier2Path.addCurve(to: CGPoint(x: 44.55, y: 6.04), controlPoint1: CGPoint(x: 43.64, y: 5.9), controlPoint2: CGPoint(x: 44.12, y: 5.9))
        bezier2Path.close()
        connectionStatusFill.setFill()
        bezier2Path.fill()


        //// Charge
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip Bezier 5
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: 17.56, y: 4.84))
        bezier5Path.addCurve(to: CGPoint(x: 17.56, y: 10.32), controlPoint1: CGPoint(x: 17.56, y: 4.84), controlPoint2: CGPoint(x: 17.56, y: 8.71))
        bezier5Path.addCurve(to: CGPoint(x: 17.56, y: 11), controlPoint1: CGPoint(x: 17.56, y: 10.74), controlPoint2: CGPoint(x: 17.56, y: 11))
        bezier5Path.addLine(to: CGPoint(x: 8.71, y: 8.2))
        bezier5Path.addLine(to: CGPoint(x: 21.44, y: 17.16))
        bezier5Path.addLine(to: CGPoint(x: 21.44, y: 12.12))
        bezier5Path.addLine(to: CGPoint(x: 30.29, y: 14.36))
        bezier5Path.addLine(to: CGPoint(x: 17.56, y: 4.84))
        bezier5Path.close()
        bezier5Path.move(to: CGPoint(x: 35, y: 4))
        bezier5Path.addLine(to: CGPoint(x: 35, y: 18))
        bezier5Path.addLine(to: CGPoint(x: 4, y: 18))
        bezier5Path.addLine(to: CGPoint(x: 4, y: 4))
        bezier5Path.addLine(to: CGPoint(x: 35, y: 4))
        bezier5Path.addLine(to: CGPoint(x: 35, y: 4))
        bezier5Path.close()
        bezier5Path.addClip()


        //// ChargeProgress Drawing
        let chargeProgressPath = UIBezierPath(rect: CGRect(x: 4, y: 4, width: batteryChargeProgressWidth, height: 14))
        batteryChargeProgressColor.setFill()
        chargeProgressPath.fill()


        context.endTransparencyLayer()
        context.restoreGState()


        //// ChargeInverse
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip Rectangle
        let rectanglePath = UIBezierPath(rect: CGRect(x: 0, y: -14, width: batteryChargeInverseWidth, height: 14))
        var rectangleTransformation = CGAffineTransform.identity
        rectangleTransformation = rectangleTransformation.translatedBy(x: 35, y: 4)
        rectangleTransformation = rectangleTransformation.rotated(by: -180 * CGFloat.pi/180)
        rectanglePath.apply(rectangleTransformation)
        rectanglePath.addClip()


        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 8.93, y: 8.32))
        bezier3Path.addLine(to: CGPoint(x: 21.38, y: 17.11))
        bezier3Path.addLine(to: CGPoint(x: 21.38, y: 12.07))
        bezier3Path.addLine(to: CGPoint(x: 30.04, y: 14.22))
        bezier3Path.addLine(to: CGPoint(x: 17.56, y: 4.84))
        bezier3Path.addLine(to: CGPoint(x: 17.59, y: 11))
        bezier3Path.addLine(to: CGPoint(x: 8.93, y: 8.32))
        bezier3Path.close()
        connectionStatusFill.setFill()
        bezier3Path.fill()


        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc dynamic public class func drawBatteryAnimatedCharging(batteryCharge: CGFloat = 0.5, batteryChargeTextValue: String = "50%") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let connectionStatusFill = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let connectionStatusRed = UIColor(red: 0.776, green: 0.000, blue: 0.000, alpha: 1.000)
        let fillColor2 = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Variable Declarations
        let batteryChargeWidth: CGFloat = 31
        let batteryChargeProgressWidth: CGFloat = batteryCharge * batteryChargeWidth
        let batteryChargeProgressColor = batteryCharge > 0.25 ? connectionStatusFill : connectionStatusRed

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 35.72, y: 3.22))
        bezierPath.addLine(to: CGPoint(x: 3.25, y: 3.22))
        bezierPath.addLine(to: CGPoint(x: 3.25, y: 18.78))
        bezierPath.addLine(to: CGPoint(x: 35.72, y: 18.78))
        bezierPath.addLine(to: CGPoint(x: 35.72, y: 3.22))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 38.96, y: 0))
        bezierPath.addCurve(to: CGPoint(x: 38.96, y: 22), controlPoint1: CGPoint(x: 38.96, y: 0), controlPoint2: CGPoint(x: 38.96, y: 22))
        bezierPath.addLine(to: CGPoint(x: 0, y: 22))
        bezierPath.addLine(to: CGPoint(x: 0, y: 0))
        bezierPath.addLine(to: CGPoint(x: 38.96, y: 0))
        bezierPath.addLine(to: CGPoint(x: 38.96, y: 0))
        bezierPath.close()
        connectionStatusFill.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 44.55, y: 6.04))
        bezier2Path.addLine(to: CGPoint(x: 44.63, y: 6.06))
        bezier2Path.addCurve(to: CGPoint(x: 45.84, y: 7.26), controlPoint1: CGPoint(x: 45.19, y: 6.27), controlPoint2: CGPoint(x: 45.63, y: 6.7))
        bezier2Path.addCurve(to: CGPoint(x: 46, y: 9.18), controlPoint1: CGPoint(x: 46, y: 7.77), controlPoint2: CGPoint(x: 46, y: 8.24))
        bezier2Path.addLine(to: CGPoint(x: 46, y: 12.82))
        bezier2Path.addCurve(to: CGPoint(x: 45.86, y: 14.66), controlPoint1: CGPoint(x: 46, y: 13.76), controlPoint2: CGPoint(x: 46, y: 14.23))
        bezier2Path.addLine(to: CGPoint(x: 45.84, y: 14.74))
        bezier2Path.addCurve(to: CGPoint(x: 44.63, y: 15.94), controlPoint1: CGPoint(x: 45.63, y: 15.3), controlPoint2: CGPoint(x: 45.19, y: 15.73))
        bezier2Path.addCurve(to: CGPoint(x: 42.69, y: 16.1), controlPoint1: CGPoint(x: 44.12, y: 16.1), controlPoint2: CGPoint(x: 43.64, y: 16.1))
        bezier2Path.addLine(to: CGPoint(x: 41.13, y: 16.1))
        bezier2Path.addCurve(to: CGPoint(x: 41.13, y: 5.9), controlPoint1: CGPoint(x: 41.13, y: 13.43), controlPoint2: CGPoint(x: 41.13, y: 8.16))
        bezier2Path.addLine(to: CGPoint(x: 42.69, y: 5.9))
        bezier2Path.addCurve(to: CGPoint(x: 44.55, y: 6.04), controlPoint1: CGPoint(x: 43.64, y: 5.9), controlPoint2: CGPoint(x: 44.12, y: 5.9))
        bezier2Path.close()
        connectionStatusFill.setFill()
        bezier2Path.fill()


        //// Group
        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRect(x: 4, y: 4, width: batteryChargeProgressWidth, height: 14))
        connectionStatusFill.setFill()
        rectanglePath.fill()


        //// Text Drawing
        let textRect = CGRect(x: 4, y: 5, width: 31, height: 12)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: connectionStatusFill,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = batteryChargeTextValue.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        batteryChargeTextValue.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()




        //// Group 2
        context.saveGState()
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        //// Clip Rectangle 2
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 4, y: 4, width: batteryChargeProgressWidth, height: 14))
        rectangle2Path.addClip()


        //// Text 2 Drawing
        let text2Rect = CGRect(x: 4, y: 5, width: 31, height: 12)
        let text2Style = NSMutableParagraphStyle()
        text2Style.alignment = .center
        let text2FontAttributes = [
            .font: UIFont.systemFont(ofSize: 11),
            .foregroundColor: fillColor2,
            .paragraphStyle: text2Style,
        ] as [NSAttributedString.Key: Any]

        let text2TextHeight: CGFloat = batteryChargeTextValue.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: text2Rect)
        batteryChargeTextValue.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()
    }

    @objc dynamic public class func drawSignalStrength(signalStrengthValue: CGFloat = 5) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let connectionStatusFill = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black
        shadow.shadowOffset = CGSize(width: 0, height: 0)
        shadow.shadowBlurRadius = 1

        //// Variable Declarations
        let ssi4 = signalStrengthValue >= 4
        let ssi5 = signalStrengthValue >= 5
        let ssi2 = signalStrengthValue >= 2
        let ssi3 = signalStrengthValue >= 3
        let ssi1 = signalStrengthValue >= 1

        //// Group
        //// Rectangle 6 Drawing
        let rectangle6Path = UIBezierPath()
        rectangle6Path.move(to: CGPoint(x: 1, y: 21))
        rectangle6Path.addLine(to: CGPoint(x: 7.55, y: 21))
        rectangle6Path.addLine(to: CGPoint(x: 7.55, y: 20.35))
        rectangle6Path.addLine(to: CGPoint(x: 1, y: 20.35))
        rectangle6Path.addLine(to: CGPoint(x: 1, y: 21))
        rectangle6Path.close()
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        connectionStatusFill.setFill()
        rectangle6Path.fill()
        context.restoreGState()



        //// Rectangle 7 Drawing
        let rectangle7Path = UIBezierPath()
        rectangle7Path.move(to: CGPoint(x: 8.86, y: 21))
        rectangle7Path.addLine(to: CGPoint(x: 15.41, y: 21))
        rectangle7Path.addLine(to: CGPoint(x: 15.41, y: 20.35))
        rectangle7Path.addLine(to: CGPoint(x: 8.86, y: 20.35))
        rectangle7Path.addLine(to: CGPoint(x: 8.86, y: 21))
        rectangle7Path.close()
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        connectionStatusFill.setFill()
        rectangle7Path.fill()
        context.restoreGState()



        //// Rectangle 8 Drawing
        let rectangle8Path = UIBezierPath()
        rectangle8Path.move(to: CGPoint(x: 16.72, y: 21))
        rectangle8Path.addLine(to: CGPoint(x: 23.28, y: 21))
        rectangle8Path.addLine(to: CGPoint(x: 23.28, y: 20.35))
        rectangle8Path.addLine(to: CGPoint(x: 16.72, y: 20.35))
        rectangle8Path.addLine(to: CGPoint(x: 16.72, y: 21))
        rectangle8Path.close()
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        connectionStatusFill.setFill()
        rectangle8Path.fill()
        context.restoreGState()



        //// Rectangle 9 Drawing
        let rectangle9Path = UIBezierPath()
        rectangle9Path.move(to: CGPoint(x: 24.59, y: 21))
        rectangle9Path.addLine(to: CGPoint(x: 31.14, y: 21))
        rectangle9Path.addLine(to: CGPoint(x: 31.14, y: 20.35))
        rectangle9Path.addLine(to: CGPoint(x: 24.59, y: 20.35))
        rectangle9Path.addLine(to: CGPoint(x: 24.59, y: 21))
        rectangle9Path.close()
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        connectionStatusFill.setFill()
        rectangle9Path.fill()
        context.restoreGState()



        //// Rectangle 10 Drawing
        let rectangle10Path = UIBezierPath()
        rectangle10Path.move(to: CGPoint(x: 32.45, y: 21))
        rectangle10Path.addLine(to: CGPoint(x: 39, y: 21))
        rectangle10Path.addLine(to: CGPoint(x: 39, y: 20.35))
        rectangle10Path.addLine(to: CGPoint(x: 32.45, y: 20.35))
        rectangle10Path.addLine(to: CGPoint(x: 32.45, y: 21))
        rectangle10Path.close()
        context.saveGState()
        context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
        connectionStatusFill.setFill()
        rectangle10Path.fill()
        context.restoreGState()



        if (ssi1) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath()
            rectanglePath.move(to: CGPoint(x: 1, y: 21))
            rectanglePath.addLine(to: CGPoint(x: 7.55, y: 21))
            rectanglePath.addLine(to: CGPoint(x: 7.55, y: 12.61))
            rectanglePath.addLine(to: CGPoint(x: 1, y: 12.61))
            rectanglePath.addLine(to: CGPoint(x: 1, y: 21))
            rectanglePath.close()
            context.saveGState()
            context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
            connectionStatusFill.setFill()
            rectanglePath.fill()
            context.restoreGState()

        }


        if (ssi2) {
            //// Rectangle 2 Drawing
            let rectangle2Path = UIBezierPath()
            rectangle2Path.move(to: CGPoint(x: 8.86, y: 21))
            rectangle2Path.addLine(to: CGPoint(x: 15.41, y: 21))
            rectangle2Path.addLine(to: CGPoint(x: 15.41, y: 10.68))
            rectangle2Path.addLine(to: CGPoint(x: 8.86, y: 10.68))
            rectangle2Path.addLine(to: CGPoint(x: 8.86, y: 21))
            rectangle2Path.close()
            context.saveGState()
            context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
            connectionStatusFill.setFill()
            rectangle2Path.fill()
            context.restoreGState()

        }


        if (ssi3) {
            //// Rectangle 3 Drawing
            let rectangle3Path = UIBezierPath()
            rectangle3Path.move(to: CGPoint(x: 16.72, y: 21))
            rectangle3Path.addLine(to: CGPoint(x: 23.28, y: 21))
            rectangle3Path.addLine(to: CGPoint(x: 23.28, y: 8.1))
            rectangle3Path.addLine(to: CGPoint(x: 16.72, y: 8.1))
            rectangle3Path.addLine(to: CGPoint(x: 16.72, y: 21))
            rectangle3Path.close()
            context.saveGState()
            context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
            connectionStatusFill.setFill()
            rectangle3Path.fill()
            context.restoreGState()

        }


        if (ssi4) {
            //// Rectangle 4 Drawing
            let rectangle4Path = UIBezierPath()
            rectangle4Path.move(to: CGPoint(x: 24.59, y: 21))
            rectangle4Path.addLine(to: CGPoint(x: 31.14, y: 21))
            rectangle4Path.addLine(to: CGPoint(x: 31.14, y: 4.87))
            rectangle4Path.addLine(to: CGPoint(x: 24.59, y: 4.87))
            rectangle4Path.addLine(to: CGPoint(x: 24.59, y: 21))
            rectangle4Path.close()
            context.saveGState()
            context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
            connectionStatusFill.setFill()
            rectangle4Path.fill()
            context.restoreGState()

        }


        if (ssi5) {
            //// Rectangle 5 Drawing
            let rectangle5Path = UIBezierPath()
            rectangle5Path.move(to: CGPoint(x: 32.45, y: 21))
            rectangle5Path.addLine(to: CGPoint(x: 39, y: 21))
            rectangle5Path.addLine(to: CGPoint(x: 39, y: 1))
            rectangle5Path.addLine(to: CGPoint(x: 32.45, y: 1))
            rectangle5Path.addLine(to: CGPoint(x: 32.45, y: 21))
            rectangle5Path.close()
            context.saveGState()
            context.setShadow(offset: shadow.shadowOffset, blur: shadow.shadowBlurRadius, color: (shadow.shadowColor as! UIColor).cgColor)
            connectionStatusFill.setFill()
            rectangle5Path.fill()
            context.restoreGState()

        }
    }

    @objc dynamic public class func drawActiveCallButton09(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "WXYZ"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "9"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()


        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawActiveCallKeypad(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 192, height: 211), resizing: ResizingBehavior = .aspectFit, pressed2: Bool = true, keypadText: String = "Keypad") {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 192, height: 211), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 192, y: resizedFrame.height / 211)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 192, resizedFrame.height / 211)


        //// Color Declarations
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonStrokeShadow = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let activeCallButtonPressedBackground = UIColor(red: 0.247, green: 0.247, blue: 0.247, alpha: 1.000)

        //// Shadow Declarations
        let activeCallIconDropShadow = NSShadow()
        activeCallIconDropShadow.shadowColor = UIColor.black
        activeCallIconDropShadow.shadowOffset = CGSize(width: 2, height: 2)
        activeCallIconDropShadow.shadowBlurRadius = 3
        let activeCallHorizontealBorderShadow = NSShadow()
        activeCallHorizontealBorderShadow.shadowColor = UIColor.black
        activeCallHorizontealBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallHorizontealBorderShadow.shadowBlurRadius = 2.5

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -10, y: -10, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -10, y: -10, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonPressedBackground.setFill()
            pressedBackgroundPath.fill()
        }


        //// Text Drawing
        let textRect = CGRect(x: 0, y: 162, width: 192, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 32),
            .foregroundColor: activeCallButtonStroke,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = keypadText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        keypadText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 66, y: 73))
        bezierPath.addLine(to: CGPoint(x: 81, y: 73))
        bezierPath.addLine(to: CGPoint(x: 81, y: 58))
        bezierPath.addLine(to: CGPoint(x: 66, y: 58))
        bezierPath.addLine(to: CGPoint(x: 66, y: 73))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 91, y: 73))
        bezierPath.addLine(to: CGPoint(x: 106, y: 73))
        bezierPath.addLine(to: CGPoint(x: 106, y: 58))
        bezierPath.addLine(to: CGPoint(x: 91, y: 58))
        bezierPath.addLine(to: CGPoint(x: 91, y: 73))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 116, y: 73))
        bezierPath.addLine(to: CGPoint(x: 131, y: 73))
        bezierPath.addLine(to: CGPoint(x: 131, y: 58))
        bezierPath.addLine(to: CGPoint(x: 116, y: 58))
        bezierPath.addLine(to: CGPoint(x: 116, y: 73))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 66, y: 97))
        bezierPath.addLine(to: CGPoint(x: 81, y: 97))
        bezierPath.addLine(to: CGPoint(x: 81, y: 82))
        bezierPath.addLine(to: CGPoint(x: 66, y: 82))
        bezierPath.addLine(to: CGPoint(x: 66, y: 97))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 91, y: 97))
        bezierPath.addLine(to: CGPoint(x: 106, y: 97))
        bezierPath.addLine(to: CGPoint(x: 106, y: 82))
        bezierPath.addLine(to: CGPoint(x: 91, y: 82))
        bezierPath.addLine(to: CGPoint(x: 91, y: 97))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 116, y: 97))
        bezierPath.addLine(to: CGPoint(x: 131, y: 97))
        bezierPath.addLine(to: CGPoint(x: 131, y: 82))
        bezierPath.addLine(to: CGPoint(x: 116, y: 82))
        bezierPath.addLine(to: CGPoint(x: 116, y: 97))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 66, y: 124))
        bezierPath.addLine(to: CGPoint(x: 81, y: 124))
        bezierPath.addLine(to: CGPoint(x: 81, y: 109))
        bezierPath.addLine(to: CGPoint(x: 66, y: 109))
        bezierPath.addLine(to: CGPoint(x: 66, y: 124))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 91, y: 124))
        bezierPath.addLine(to: CGPoint(x: 106, y: 124))
        bezierPath.addLine(to: CGPoint(x: 106, y: 109))
        bezierPath.addLine(to: CGPoint(x: 91, y: 109))
        bezierPath.addLine(to: CGPoint(x: 91, y: 124))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 116, y: 124))
        bezierPath.addLine(to: CGPoint(x: 131, y: 124))
        bezierPath.addLine(to: CGPoint(x: 131, y: 109))
        bezierPath.addLine(to: CGPoint(x: 116, y: 109))
        bezierPath.addLine(to: CGPoint(x: 116, y: 124))
        bezierPath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        bezierPath.fill()
        context.restoreGState()



        //// Outline
        //// RightEdge Drawing
        let rightEdgePath = UIBezierPath()
        rightEdgePath.move(to: CGPoint(x: 192, y: 0))
        rightEdgePath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        rightEdgePath.lineWidth = 1
        rightEdgePath.stroke()


        //// BottomEdge Drawing
        let bottomEdgePath = UIBezierPath()
        bottomEdgePath.move(to: CGPoint(x: 0, y: 211))
        bottomEdgePath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        bottomEdgePath.lineWidth = 1
        bottomEdgePath.stroke()


        //// LeftEdge Drawing
        let leftEdgePath = UIBezierPath()
        leftEdgePath.move(to: CGPoint(x: 0.5, y: 0))
        leftEdgePath.addLine(to: CGPoint(x: 0.5, y: 211))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallHorizontealBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallHorizontealBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallHorizontealBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallHorizontealBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        leftEdgePath.lineWidth = 1
        leftEdgePath.stroke()
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawDialPadDelete(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectangleRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let rectanglePath = UIBezierPath(rect: rectangleRect)
            context.saveGState()
            rectanglePath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: rectangleRect.midX, y: rectangleRect.minY),
                end: CGPoint(x: rectangleRect.midX, y: rectangleRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.99500 * group.height))
        bezier3Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 0.00000 * group.height))
        bezier4Path.addLine(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 1.00000 * group.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.00501 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.99692 * group.width, y: group.minY + 0.00501 * group.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        bezier2Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.00500 * group.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()






        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: group.minX + 0.54950 * group.width, y: group.minY + 0.43293 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.51692 * group.width, y: group.minY + 0.48586 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.48435 * group.width, y: group.minY + 0.43293 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.47565 * group.width, y: group.minY + 0.44707 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.50822 * group.width, y: group.minY + 0.50000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.47565 * group.width, y: group.minY + 0.55293 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.48435 * group.width, y: group.minY + 0.56707 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.51692 * group.width, y: group.minY + 0.51414 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.54950 * group.width, y: group.minY + 0.56707 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.55820 * group.width, y: group.minY + 0.55293 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.52563 * group.width, y: group.minY + 0.50000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.55820 * group.width, y: group.minY + 0.44707 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.54950 * group.width, y: group.minY + 0.43293 * group.height))
        bezier5Path.close()
        bezier5Path.move(to: CGPoint(x: group.minX + 0.65231 * group.width, y: group.minY + 0.39000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.65231 * group.width, y: group.minY + 0.61000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.62769 * group.width, y: group.minY + 0.65000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.65231 * group.width, y: group.minY + 0.63199 * group.height), controlPoint2: CGPoint(x: group.minX + 0.64123 * group.width, y: group.minY + 0.65000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.42180 * group.width, y: group.minY + 0.65000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.34267 * group.width, y: group.minY + 0.50000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.42180 * group.width, y: group.minY + 0.35000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.62769 * group.width, y: group.minY + 0.35000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.65231 * group.width, y: group.minY + 0.39000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.64123 * group.width, y: group.minY + 0.35000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.65231 * group.width, y: group.minY + 0.36801 * group.height))
        bezier5Path.close()
        dialPadForeground.setFill()
        bezier5Path.fill()
    }

    @objc dynamic public class func drawDialPadNumber01(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "1"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawDialPadNumber00(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "0"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "+"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallSpeaker(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 192, height: 211), resizing: ResizingBehavior = .aspectFit, speakerText: String = "Speaker", pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 192, height: 211), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 192, y: resizedFrame.height / 211)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 192, resizedFrame.height / 211)


        //// Color Declarations
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonStrokeShadow = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let activeCallButtonPressedBackground = UIColor(red: 0.247, green: 0.247, blue: 0.247, alpha: 1.000)

        //// Shadow Declarations
        let activeCallIconDropShadow = NSShadow()
        activeCallIconDropShadow.shadowColor = UIColor.black
        activeCallIconDropShadow.shadowOffset = CGSize(width: 2, height: 2)
        activeCallIconDropShadow.shadowBlurRadius = 3
        let activeCallHorizontealBorderShadow = NSShadow()
        activeCallHorizontealBorderShadow.shadowColor = UIColor.black
        activeCallHorizontealBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallHorizontealBorderShadow.shadowBlurRadius = 2.5

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -25, y: 0, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -25, y: 0, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonPressedBackground.setFill()
            pressedBackgroundPath.fill()
        }


        //// Text Drawing
        let textRect = CGRect(x: 0, y: 162, width: 192, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 32),
            .foregroundColor: activeCallButtonStroke,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = speakerText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        speakerText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Speaker Drawing
        let speakerPath = UIBezierPath()
        speakerPath.move(to: CGPoint(x: 77.73, y: 71.87))
        speakerPath.addLine(to: CGPoint(x: 77.73, y: 105.13))
        speakerPath.addLine(to: CGPoint(x: 106.14, y: 122.21))
        speakerPath.addLine(to: CGPoint(x: 106.14, y: 54.1))
        speakerPath.addLine(to: CGPoint(x: 77.73, y: 71.87))
        speakerPath.close()
        speakerPath.move(to: CGPoint(x: 59.1, y: 71.87))
        speakerPath.addCurve(to: CGPoint(x: 52.97, y: 77.45), controlPoint1: CGPoint(x: 55.71, y: 71.87), controlPoint2: CGPoint(x: 52.97, y: 74.37))
        speakerPath.addLine(to: CGPoint(x: 52.97, y: 99.55))
        speakerPath.addCurve(to: CGPoint(x: 59.1, y: 105.13), controlPoint1: CGPoint(x: 52.97, y: 102.63), controlPoint2: CGPoint(x: 55.71, y: 105.13))
        speakerPath.addLine(to: CGPoint(x: 71.14, y: 105.13))
        speakerPath.addLine(to: CGPoint(x: 71.2, y: 71.87))
        speakerPath.addLine(to: CGPoint(x: 59.1, y: 71.87))
        speakerPath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        speakerPath.fill()
        context.restoreGState()



        //// On Drawing
        let onPath = UIBezierPath()
        onPath.move(to: CGPoint(x: 119.38, y: 72.17))
        onPath.addCurve(to: CGPoint(x: 120.3, y: 73.51), controlPoint1: CGPoint(x: 119.58, y: 72.44), controlPoint2: CGPoint(x: 119.9, y: 72.89))
        onPath.addCurve(to: CGPoint(x: 122.2, y: 76.87), controlPoint1: CGPoint(x: 120.95, y: 74.51), controlPoint2: CGPoint(x: 121.59, y: 75.64))
        onPath.addCurve(to: CGPoint(x: 125, y: 88), controlPoint1: CGPoint(x: 123.94, y: 80.45), controlPoint2: CGPoint(x: 125, y: 84.21))
        onPath.addCurve(to: CGPoint(x: 124.82, y: 90.76), controlPoint1: CGPoint(x: 125, y: 88.9), controlPoint2: CGPoint(x: 124.94, y: 89.82))
        onPath.addCurve(to: CGPoint(x: 122.28, y: 99.95), controlPoint1: CGPoint(x: 124.46, y: 93.73), controlPoint2: CGPoint(x: 123.55, y: 96.83))
        onPath.addCurve(to: CGPoint(x: 120.45, y: 103.92), controlPoint1: CGPoint(x: 121.7, y: 101.37), controlPoint2: CGPoint(x: 121.07, y: 102.71))
        onPath.addCurve(to: CGPoint(x: 119.59, y: 105.52), controlPoint1: CGPoint(x: 120.07, y: 104.66), controlPoint2: CGPoint(x: 119.77, y: 105.21))
        onPath.addLine(to: CGPoint(x: 114.41, y: 102.48))
        onPath.addCurve(to: CGPoint(x: 114.59, y: 102.17), controlPoint1: CGPoint(x: 114.44, y: 102.43), controlPoint2: CGPoint(x: 114.5, y: 102.33))
        onPath.addCurve(to: CGPoint(x: 115.11, y: 101.19), controlPoint1: CGPoint(x: 114.75, y: 101.89), controlPoint2: CGPoint(x: 114.92, y: 101.56))
        onPath.addCurve(to: CGPoint(x: 116.72, y: 97.68), controlPoint1: CGPoint(x: 115.66, y: 100.12), controlPoint2: CGPoint(x: 116.21, y: 98.93))
        onPath.addCurve(to: CGPoint(x: 118.87, y: 90.02), controlPoint1: CGPoint(x: 117.81, y: 95.01), controlPoint2: CGPoint(x: 118.57, y: 92.4))
        onPath.addCurve(to: CGPoint(x: 119, y: 88), controlPoint1: CGPoint(x: 118.96, y: 89.32), controlPoint2: CGPoint(x: 119, y: 88.64))
        onPath.addCurve(to: CGPoint(x: 116.8, y: 79.5), controlPoint1: CGPoint(x: 119, y: 85.23), controlPoint2: CGPoint(x: 118.18, y: 82.33))
        onPath.addCurve(to: CGPoint(x: 115.26, y: 76.76), controlPoint1: CGPoint(x: 116.31, y: 78.49), controlPoint2: CGPoint(x: 115.78, y: 77.57))
        onPath.addCurve(to: CGPoint(x: 114.62, y: 75.83), controlPoint1: CGPoint(x: 114.96, y: 76.29), controlPoint2: CGPoint(x: 114.73, y: 75.97))
        onPath.addLine(to: CGPoint(x: 119.38, y: 72.17))
        onPath.close()
        onPath.move(to: CGPoint(x: 128.17, y: 62.74))
        onPath.addCurve(to: CGPoint(x: 129.83, y: 64.91), controlPoint1: CGPoint(x: 128.53, y: 63.16), controlPoint2: CGPoint(x: 129.11, y: 63.9))
        onPath.addCurve(to: CGPoint(x: 133.32, y: 70.48), controlPoint1: CGPoint(x: 131.02, y: 66.58), controlPoint2: CGPoint(x: 132.21, y: 68.45))
        onPath.addCurve(to: CGPoint(x: 138.5, y: 88.5), controlPoint1: CGPoint(x: 136.55, y: 76.38), controlPoint2: CGPoint(x: 138.5, y: 82.47))
        onPath.addCurve(to: CGPoint(x: 133.36, y: 106.95), controlPoint1: CGPoint(x: 138.5, y: 94.51), controlPoint2: CGPoint(x: 136.56, y: 100.76))
        onPath.addCurve(to: CGPoint(x: 129.9, y: 112.83), controlPoint1: CGPoint(x: 132.26, y: 109.08), controlPoint2: CGPoint(x: 131.08, y: 111.06))
        onPath.addCurve(to: CGPoint(x: 128.27, y: 115.14), controlPoint1: CGPoint(x: 129.18, y: 113.91), controlPoint2: CGPoint(x: 128.61, y: 114.7))
        onPath.addLine(to: CGPoint(x: 122.73, y: 110.86))
        onPath.addCurve(to: CGPoint(x: 123.07, y: 110.4), controlPoint1: CGPoint(x: 122.79, y: 110.79), controlPoint2: CGPoint(x: 122.9, y: 110.63))
        onPath.addCurve(to: CGPoint(x: 124.07, y: 108.96), controlPoint1: CGPoint(x: 123.37, y: 109.99), controlPoint2: CGPoint(x: 123.71, y: 109.5))
        onPath.addCurve(to: CGPoint(x: 127.14, y: 103.74), controlPoint1: CGPoint(x: 125.12, y: 107.38), controlPoint2: CGPoint(x: 126.16, y: 105.63))
        onPath.addCurve(to: CGPoint(x: 131.5, y: 88.5), controlPoint1: CGPoint(x: 129.88, y: 98.45), controlPoint2: CGPoint(x: 131.5, y: 93.21))
        onPath.addCurve(to: CGPoint(x: 127.18, y: 73.84), controlPoint1: CGPoint(x: 131.5, y: 83.81), controlPoint2: CGPoint(x: 129.89, y: 78.79))
        onPath.addCurve(to: CGPoint(x: 124.14, y: 68.98), controlPoint1: CGPoint(x: 126.21, y: 72.07), controlPoint2: CGPoint(x: 125.17, y: 70.43))
        onPath.addCurve(to: CGPoint(x: 123.15, y: 67.67), controlPoint1: CGPoint(x: 123.78, y: 68.48), controlPoint2: CGPoint(x: 123.45, y: 68.04))
        onPath.addCurve(to: CGPoint(x: 122.83, y: 67.26), controlPoint1: CGPoint(x: 122.99, y: 67.45), controlPoint2: CGPoint(x: 122.87, y: 67.31))
        onPath.addLine(to: CGPoint(x: 128.17, y: 62.74))
        onPath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        onPath.fill()
        context.restoreGState()



        //// Outline
        //// LeftEdge Drawing
        let leftEdgePath = UIBezierPath()
        leftEdgePath.move(to: CGPoint(x: 0.5, y: 0))
        leftEdgePath.addLine(to: CGPoint(x: 0.5, y: 211))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallHorizontealBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallHorizontealBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallHorizontealBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallHorizontealBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        leftEdgePath.lineWidth = 1
        leftEdgePath.stroke()
        context.restoreGState()


        //// BottomEdge Drawing
        let bottomEdgePath = UIBezierPath()
        bottomEdgePath.move(to: CGPoint(x: 0, y: 211))
        bottomEdgePath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        bottomEdgePath.lineWidth = 1
        bottomEdgePath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawActiveCallButton07(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "PQRS"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "7"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridRight Drawing
        let gridRightPath = UIBezierPath()
        gridRightPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        gridRightPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridRightPath.lineWidth = 1
        gridRightPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawActiveCallBlank(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 192, height: 211), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 192, height: 211), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 192, y: resizedFrame.height / 211)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 192, resizedFrame.height / 211)


        //// Color Declarations
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonStrokeShadow = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Shadow Declarations
        let activeCallVerticalBorderShadow = NSShadow()
        activeCallVerticalBorderShadow.shadowColor = UIColor.black
        activeCallVerticalBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallVerticalBorderShadow.shadowBlurRadius = 2.5
        let activeCallHorizontealBorderShadow = NSShadow()
        activeCallHorizontealBorderShadow.shadowColor = UIColor.black
        activeCallHorizontealBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallHorizontealBorderShadow.shadowBlurRadius = 2.5

        //// Group
        //// NormalBackground Drawing
        let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -10, y: -10, width: 217, height: 236), cornerRadius: 20)
        activeCallButtonBackground.setFill()
        normalBackgroundPath.fill()


        //// Text Drawing


        //// Outline
        //// RightGuide Drawing
        let rightGuidePath = UIBezierPath()
        rightGuidePath.move(to: CGPoint(x: 192, y: 0))
        rightGuidePath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        rightGuidePath.lineWidth = 1
        rightGuidePath.stroke()


        //// TopGuide Drawing
        let topGuidePath = UIBezierPath()
        topGuidePath.move(to: CGPoint(x: 0, y: 0.5))
        topGuidePath.addLine(to: CGPoint(x: 192, y: 0.5))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallVerticalBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallVerticalBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallVerticalBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallVerticalBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        topGuidePath.lineWidth = 1
        topGuidePath.stroke()
        context.restoreGState()


        //// LeftGuide Drawing
        let leftGuidePath = UIBezierPath()
        leftGuidePath.move(to: CGPoint(x: 0.5, y: 0))
        leftGuidePath.addLine(to: CGPoint(x: 0.5, y: 211))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallHorizontealBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallHorizontealBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallHorizontealBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallHorizontealBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        leftGuidePath.lineWidth = 1
        leftGuidePath.stroke()
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawDialPadNumber08(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "8"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "TUV"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButton03(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX - 25, y: frame.minY, width: 185, height: 131), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX - 25, y: frame.minY, width: 185, height: 131)
            let pressedBackgroundPath = UIBezierPath(roundedRect: pressedBackgroundRect, cornerRadius: 20)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "DEF"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "3"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawDialPadNumber09(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "9"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "WXYZ"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButton02(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "ABC"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "2"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridRight Drawing
        let gridRightPath = UIBezierPath()
        gridRightPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        gridRightPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridRightPath.lineWidth = 1
        gridRightPath.stroke()


        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawDialPadStar(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.99500 * group.height))
        bezier3Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 0.00000 * group.height))
        bezier4Path.addLine(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 1.00000 * group.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.00501 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.99692 * group.width, y: group.minY + 0.00501 * group.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        bezier2Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.00500 * group.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()






        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: group.minX + 0.51077 * group.width, y: group.minY + 0.53000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.48616 * group.width, y: group.minY + 0.53000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.48001 * group.width, y: group.minY + 0.52000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.48277 * group.width, y: group.minY + 0.53000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.48001 * group.width, y: group.minY + 0.52555 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.48001 * group.width, y: group.minY + 0.39223 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.41166 * group.width, y: group.minY + 0.45570 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.40332 * group.width, y: group.minY + 0.45207 * group.height), controlPoint1: CGPoint(x: group.minX + 0.40876 * group.width, y: group.minY + 0.45844 * group.height), controlPoint2: CGPoint(x: group.minX + 0.40503 * group.width, y: group.minY + 0.45680 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.39101 * group.width, y: group.minY + 0.41809 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.39037 * group.width, y: group.minY + 0.41047 * group.height), controlPoint1: CGPoint(x: group.minX + 0.39017 * group.width, y: group.minY + 0.41578 * group.height), controlPoint2: CGPoint(x: group.minX + 0.38993 * group.width, y: group.minY + 0.41305 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.39323 * group.width, y: group.minY + 0.40437 * group.height), controlPoint1: CGPoint(x: group.minX + 0.39077 * group.width, y: group.minY + 0.40789 * group.height), controlPoint2: CGPoint(x: group.minX + 0.39181 * group.width, y: group.minY + 0.40570 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.46157 * group.width, y: group.minY + 0.34000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.39323 * group.width, y: group.minY + 0.27566 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.39037 * group.width, y: group.minY + 0.26953 * group.height), controlPoint1: CGPoint(x: group.minX + 0.39181 * group.width, y: group.minY + 0.27434 * group.height), controlPoint2: CGPoint(x: group.minX + 0.39077 * group.width, y: group.minY + 0.27211 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.39099 * group.width, y: group.minY + 0.26191 * group.height), controlPoint1: CGPoint(x: group.minX + 0.38993 * group.width, y: group.minY + 0.26695 * group.height), controlPoint2: CGPoint(x: group.minX + 0.39017 * group.width, y: group.minY + 0.26422 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.40330 * group.width, y: group.minY + 0.22793 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.41166 * group.width, y: group.minY + 0.22434 * group.height), controlPoint1: CGPoint(x: group.minX + 0.40501 * group.width, y: group.minY + 0.22320 * group.height), controlPoint2: CGPoint(x: group.minX + 0.40876 * group.width, y: group.minY + 0.22160 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.48001 * group.width, y: group.minY + 0.28777 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.48001 * group.width, y: group.minY + 0.16000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.48616 * group.width, y: group.minY + 0.15000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.48001 * group.width, y: group.minY + 0.15449 * group.height), controlPoint2: CGPoint(x: group.minX + 0.48277 * group.width, y: group.minY + 0.15000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.51077 * group.width, y: group.minY + 0.15000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.51693 * group.width, y: group.minY + 0.16000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.51419 * group.width, y: group.minY + 0.15000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.51693 * group.width, y: group.minY + 0.15449 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.51693 * group.width, y: group.minY + 0.28777 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.58527 * group.width, y: group.minY + 0.22434 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.59361 * group.width, y: group.minY + 0.22793 * group.height), controlPoint1: CGPoint(x: group.minX + 0.58818 * group.width, y: group.minY + 0.22160 * group.height), controlPoint2: CGPoint(x: group.minX + 0.59190 * group.width, y: group.minY + 0.22320 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.60592 * group.width, y: group.minY + 0.26191 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.60657 * group.width, y: group.minY + 0.26953 * group.height), controlPoint1: CGPoint(x: group.minX + 0.60676 * group.width, y: group.minY + 0.26422 * group.height), controlPoint2: CGPoint(x: group.minX + 0.60700 * group.width, y: group.minY + 0.26695 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.60371 * group.width, y: group.minY + 0.27566 * group.height), controlPoint1: CGPoint(x: group.minX + 0.60616 * group.width, y: group.minY + 0.27211 * group.height), controlPoint2: CGPoint(x: group.minX + 0.60513 * group.width, y: group.minY + 0.27434 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.53537 * group.width, y: group.minY + 0.34000 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.60371 * group.width, y: group.minY + 0.40434 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.60657 * group.width, y: group.minY + 0.41047 * group.height), controlPoint1: CGPoint(x: group.minX + 0.60510 * group.width, y: group.minY + 0.40570 * group.height), controlPoint2: CGPoint(x: group.minX + 0.60614 * group.width, y: group.minY + 0.40789 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.60592 * group.width, y: group.minY + 0.41809 * group.height), controlPoint1: CGPoint(x: group.minX + 0.60698 * group.width, y: group.minY + 0.41305 * group.height), controlPoint2: CGPoint(x: group.minX + 0.60676 * group.width, y: group.minY + 0.41578 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.59361 * group.width, y: group.minY + 0.45207 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.58527 * group.width, y: group.minY + 0.45566 * group.height), controlPoint1: CGPoint(x: group.minX + 0.59190 * group.width, y: group.minY + 0.45680 * group.height), controlPoint2: CGPoint(x: group.minX + 0.58818 * group.width, y: group.minY + 0.45844 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.51693 * group.width, y: group.minY + 0.39223 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.51693 * group.width, y: group.minY + 0.52000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.51077 * group.width, y: group.minY + 0.53000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.51693 * group.width, y: group.minY + 0.52555 * group.height), controlPoint2: CGPoint(x: group.minX + 0.51419 * group.width, y: group.minY + 0.53000 * group.height))
        bezier5Path.close()
        dialPadForeground.setFill()
        bezier5Path.fill()
    }

    @objc dynamic public class func drawDialPadNumber06(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "6"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "MNO"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButton01(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY, width: 185, height: 131), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 185, height: 131)
            let pressedBackgroundPath = UIBezierPath(roundedRect: pressedBackgroundRect, cornerRadius: 20)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "1"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// RightGrid Drawing
        let rightGridPath = UIBezierPath()
        rightGridPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        rightGridPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        rightGridPath.lineWidth = 1
        rightGridPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawDialPadNumber05(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "5"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "JKL"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButton00(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "+"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "0"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridRight Drawing
        let gridRightPath = UIBezierPath()
        gridRightPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        gridRightPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridRightPath.lineWidth = 1
        gridRightPath.stroke()


        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 0))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()
    }

    @objc dynamic public class func drawActiveCallTransfer(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 192, height: 211), resizing: ResizingBehavior = .aspectFit, callTransferText: String = "Transfer", pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 192, height: 211), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 192, y: resizedFrame.height / 211)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 192, resizedFrame.height / 211)


        //// Color Declarations
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonStrokeShadow = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let activeCallButtonPressedBackground = UIColor(red: 0.247, green: 0.247, blue: 0.247, alpha: 1.000)

        //// Shadow Declarations
        let activeCallVerticalBorderShadow = NSShadow()
        activeCallVerticalBorderShadow.shadowColor = UIColor.black
        activeCallVerticalBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallVerticalBorderShadow.shadowBlurRadius = 2.5
        let activeCallIconDropShadow = NSShadow()
        activeCallIconDropShadow.shadowColor = UIColor.black
        activeCallIconDropShadow.shadowOffset = CGSize(width: 2, height: 2)
        activeCallIconDropShadow.shadowBlurRadius = 3

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 0, y: -25, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 0, y: -25, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonPressedBackground.setFill()
            pressedBackgroundPath.fill()
        }


        //// Text Drawing
        let textRect = CGRect(x: 0, y: 162, width: 192, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 32),
            .foregroundColor: activeCallButtonStroke,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = callTransferText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        callTransferText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Outline
        //// RightGuide Drawing
        let rightGuidePath = UIBezierPath()
        rightGuidePath.move(to: CGPoint(x: 192, y: 0))
        rightGuidePath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        rightGuidePath.lineWidth = 1
        rightGuidePath.stroke()


        //// TopGuide Drawing
        let topGuidePath = UIBezierPath()
        topGuidePath.move(to: CGPoint(x: 0.5, y: 0))
        topGuidePath.addLine(to: CGPoint(x: 192.5, y: 0))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallVerticalBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallVerticalBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallVerticalBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallVerticalBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        topGuidePath.lineWidth = 1
        topGuidePath.stroke()
        context.restoreGState()




        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        bezier3Path.fill()
        context.restoreGState()



        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 98.66, y: 116.39))
        bezier4Path.addCurve(to: CGPoint(x: 98.59, y: 116.37), controlPoint1: CGPoint(x: 98.63, y: 116.38), controlPoint2: CGPoint(x: 98.61, y: 116.38))
        bezier4Path.addCurve(to: CGPoint(x: 72.82, y: 88), controlPoint1: CGPoint(x: 88.27, y: 113.31), controlPoint2: CGPoint(x: 78.88, y: 99.25))
        bezier4Path.addCurve(to: CGPoint(x: 62.63, y: 49.67), controlPoint1: CGPoint(x: 66.75, y: 76.74), controlPoint2: CGPoint(x: 60.06, y: 60.95))
        bezier4Path.addCurve(to: CGPoint(x: 74.37, y: 40.99), controlPoint1: CGPoint(x: 63.53, y: 45.71), controlPoint2: CGPoint(x: 74.26, y: 41.04))
        bezier4Path.addCurve(to: CGPoint(x: 80.2, y: 42.98), controlPoint1: CGPoint(x: 77.14, y: 39.85), controlPoint2: CGPoint(x: 79.55, y: 41.13))
        bezier4Path.addCurve(to: CGPoint(x: 84.95, y: 58.5), controlPoint1: CGPoint(x: 80.64, y: 44.24), controlPoint2: CGPoint(x: 84.54, y: 57.06))
        bezier4Path.addCurve(to: CGPoint(x: 83.31, y: 63.62), controlPoint1: CGPoint(x: 85.38, y: 60.01), controlPoint2: CGPoint(x: 84.77, y: 61.92))
        bezier4Path.addCurve(to: CGPoint(x: 78.69, y: 68.75), controlPoint1: CGPoint(x: 82.5, y: 64.56), controlPoint2: CGPoint(x: 79.9, y: 67.42))
        bezier4Path.addCurve(to: CGPoint(x: 84.17, y: 80.71), controlPoint1: CGPoint(x: 79.22, y: 70.33), controlPoint2: CGPoint(x: 80.69, y: 74.26))
        bezier4Path.addCurve(to: CGPoint(x: 91.09, y: 91.76), controlPoint1: CGPoint(x: 87.65, y: 87.16), controlPoint2: CGPoint(x: 90.07, y: 90.48))
        bezier4Path.addCurve(to: CGPoint(x: 97.44, y: 89.85), controlPoint1: CGPoint(x: 92.74, y: 91.25), controlPoint2: CGPoint(x: 96.3, y: 90.16))
        bezier4Path.addCurve(to: CGPoint(x: 102.31, y: 90.75), controlPoint1: CGPoint(x: 99.48, y: 89.29), controlPoint2: CGPoint(x: 101.3, y: 89.63))
        bezier4Path.addCurve(to: CGPoint(x: 112.43, y: 102.83), controlPoint1: CGPoint(x: 103.34, y: 91.89), controlPoint2: CGPoint(x: 111.68, y: 101.88))
        bezier4Path.addCurve(to: CGPoint(x: 113.11, y: 106.02), controlPoint1: CGPoint(x: 113.07, y: 103.64), controlPoint2: CGPoint(x: 113.31, y: 104.8))
        bezier4Path.addCurve(to: CGPoint(x: 111.2, y: 109.38), controlPoint1: CGPoint(x: 112.89, y: 107.26), controlPoint2: CGPoint(x: 112.21, y: 108.45))
        bezier4Path.addCurve(to: CGPoint(x: 98.66, y: 116.39), controlPoint1: CGPoint(x: 111.12, y: 109.46), controlPoint2: CGPoint(x: 102.26, y: 117.32))
        bezier4Path.close()
        bezier4Path.move(to: CGPoint(x: 110.82, y: 82.07))
        bezier4Path.addCurve(to: CGPoint(x: 109.8, y: 81.6), controlPoint1: CGPoint(x: 110.49, y: 82.06), controlPoint2: CGPoint(x: 109.98, y: 81.94))
        bezier4Path.addLine(to: CGPoint(x: 107.09, y: 76.51))
        bezier4Path.addLine(to: CGPoint(x: 92.41, y: 84.11))
        bezier4Path.addCurve(to: CGPoint(x: 91.2, y: 83.62), controlPoint1: CGPoint(x: 92, y: 84.33), controlPoint2: CGPoint(x: 91.46, y: 84.11))
        bezier4Path.addLine(to: CGPoint(x: 86.08, y: 73.99))
        bezier4Path.addCurve(to: CGPoint(x: 86.35, y: 72.71), controlPoint1: CGPoint(x: 85.82, y: 73.5), controlPoint2: CGPoint(x: 85.94, y: 72.93))
        bezier4Path.addLine(to: CGPoint(x: 101.04, y: 65.11))
        bezier4Path.addLine(to: CGPoint(x: 97.59, y: 58.64))
        bezier4Path.addCurve(to: CGPoint(x: 97.78, y: 57.53), controlPoint1: CGPoint(x: 97.42, y: 58.31), controlPoint2: CGPoint(x: 97.6, y: 57.81))
        bezier4Path.addCurve(to: CGPoint(x: 98.59, y: 57.21), controlPoint1: CGPoint(x: 97.95, y: 57.25), controlPoint2: CGPoint(x: 98.26, y: 57.13))
        bezier4Path.addLine(to: CGPoint(x: 118.7, y: 61.04))
        bezier4Path.addCurve(to: CGPoint(x: 119.36, y: 61.59), controlPoint1: CGPoint(x: 118.97, y: 61.11), controlPoint2: CGPoint(x: 119.22, y: 61.31))
        bezier4Path.addCurve(to: CGPoint(x: 119.45, y: 62.44), controlPoint1: CGPoint(x: 119.51, y: 61.86), controlPoint2: CGPoint(x: 119.54, y: 62.18))
        bezier4Path.addLine(to: CGPoint(x: 111.54, y: 81.57))
        bezier4Path.addCurve(to: CGPoint(x: 110.82, y: 82.07), controlPoint1: CGPoint(x: 111.48, y: 81.76), controlPoint2: CGPoint(x: 110.95, y: 82.08))
        bezier4Path.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        bezier4Path.fill()
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawActiveCallButtonHash(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX - 25, y: frame.minY - 25, width: 185, height: 131), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX - 25, y: frame.minY - 25, width: 185, height: 131)
            let pressedBackgroundPath = UIBezierPath(roundedRect: pressedBackgroundRect, cornerRadius: 20)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "#"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 0))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()
    }

    @objc dynamic public class func drawDialPadNumber03(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "3"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "DEF"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButton05(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "JLK"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "5"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridRight Drawing
        let gridRightPath = UIBezierPath()
        gridRightPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        gridRightPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridRightPath.lineWidth = 1
        gridRightPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()


        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawActiveCallButton04(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "GHI"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "4"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridRight Drawing
        let gridRightPath = UIBezierPath()
        gridRightPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        gridRightPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridRightPath.lineWidth = 1
        gridRightPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawDialPadHash(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "#"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallBlueTooth(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 192, height: 211), resizing: ResizingBehavior = .aspectFit, blueToothText: String = "Bluetooth", pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 192, height: 211), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 192, y: resizedFrame.height / 211)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 192, resizedFrame.height / 211)


        //// Color Declarations
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonStrokeShadow = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        let activeCallButtonPressedBackground = UIColor(red: 0.247, green: 0.247, blue: 0.247, alpha: 1.000)

        //// Shadow Declarations
        let activeCallVerticalBorderShadow = NSShadow()
        activeCallVerticalBorderShadow.shadowColor = UIColor.black
        activeCallVerticalBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallVerticalBorderShadow.shadowBlurRadius = 2.5
        let activeCallIconDropShadow = NSShadow()
        activeCallIconDropShadow.shadowColor = UIColor.black
        activeCallIconDropShadow.shadowOffset = CGSize(width: 2, height: 2)
        activeCallIconDropShadow.shadowBlurRadius = 3
        let activeCallHorizontealBorderShadow = NSShadow()
        activeCallHorizontealBorderShadow.shadowColor = UIColor.black
        activeCallHorizontealBorderShadow.shadowOffset = CGSize(width: 0, height: 0)
        activeCallHorizontealBorderShadow.shadowBlurRadius = 2.5

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -25, y: -25, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundPath = UIBezierPath(roundedRect: CGRect(x: -25, y: -25, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonPressedBackground.setFill()
            pressedBackgroundPath.fill()
        }


        //// Text Drawing
        let textRect = CGRect(x: 0, y: 162, width: 192, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 32),
            .foregroundColor: activeCallButtonStroke,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = blueToothText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        blueToothText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 93.16, y: 38))
        bezierPath.addLine(to: CGPoint(x: 93.16, y: 68.74))
        bezierPath.addLine(to: CGPoint(x: 79.98, y: 56.23))
        bezierPath.addLine(to: CGPoint(x: 75.05, y: 60.95))
        bezierPath.addLine(to: CGPoint(x: 91.74, y: 76.74))
        bezierPath.addLine(to: CGPoint(x: 75, y: 92.68))
        bezierPath.addLine(to: CGPoint(x: 79.98, y: 97.36))
        bezierPath.addLine(to: CGPoint(x: 93.16, y: 84.79))
        bezierPath.addLine(to: CGPoint(x: 93.16, y: 116))
        bezierPath.addLine(to: CGPoint(x: 99.13, y: 110.29))
        bezierPath.addLine(to: CGPoint(x: 115.54, y: 94.6))
        bezierPath.addLine(to: CGPoint(x: 118, y: 92.27))
        bezierPath.addLine(to: CGPoint(x: 115.54, y: 89.93))
        bezierPath.addLine(to: CGPoint(x: 101.59, y: 76.74))
        bezierPath.addLine(to: CGPoint(x: 115.48, y: 63.5))
        bezierPath.addLine(to: CGPoint(x: 117.95, y: 61.16))
        bezierPath.addLine(to: CGPoint(x: 115.43, y: 58.82))
        bezierPath.addLine(to: CGPoint(x: 99.13, y: 43.56))
        bezierPath.addLine(to: CGPoint(x: 93.16, y: 38))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 100.17, y: 53.84))
        bezierPath.addLine(to: CGPoint(x: 108.04, y: 61.16))
        bezierPath.addLine(to: CGPoint(x: 100.17, y: 68.69))
        bezierPath.addLine(to: CGPoint(x: 100.17, y: 53.84))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 100.17, y: 84.74))
        bezierPath.addLine(to: CGPoint(x: 108.15, y: 92.27))
        bezierPath.addLine(to: CGPoint(x: 100.17, y: 99.9))
        bezierPath.addLine(to: CGPoint(x: 100.17, y: 84.74))
        bezierPath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        bezierPath.fill()
        context.restoreGState()



        //// Outline
        //// LeftGuide Drawing
        let leftGuidePath = UIBezierPath()
        leftGuidePath.move(to: CGPoint(x: 0.5, y: 0))
        leftGuidePath.addLine(to: CGPoint(x: 0.5, y: 211))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallHorizontealBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallHorizontealBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallHorizontealBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallHorizontealBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        leftGuidePath.lineWidth = 1
        leftGuidePath.stroke()
        context.restoreGState()


        //// TopGuide Drawing
        let topGuidePath = UIBezierPath()
        topGuidePath.move(to: CGPoint(x: 0.5, y: 0))
        topGuidePath.addLine(to: CGPoint(x: 192.5, y: 0))
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallVerticalBorderShadow.shadowOffset.width * resizedShadowScale, height: activeCallVerticalBorderShadow.shadowOffset.height * resizedShadowScale), blur: activeCallVerticalBorderShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallVerticalBorderShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStrokeShadow.setStroke()
        topGuidePath.lineWidth = 1
        topGuidePath.stroke()
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawDialPadCall(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let callButtonGraidentColor3 = UIColor(red: 0.153, green: 0.667, blue: 0.165, alpha: 1.000)
        let callButtonGraidentColor = UIColor(red: 0.596, green: 0.804, blue: 0.580, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadCallPressedFill = UIColor(red: 0.533, green: 0.784, blue: 0.518, alpha: 1.000)
        let callButtonGraidentColor2 = UIColor(red: 0.255, green: 0.698, blue: 0.235, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let callButtonGraidentColor4 = UIColor(red: 0.133, green: 0.631, blue: 0.102, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)

        //// Gradient Declarations
        let callButtonGraident = CGGradient(colorsSpace: nil, colors: [callButtonGraidentColor.cgColor, callButtonGraidentColor2.cgColor, callButtonGraidentColor4.cgColor, callButtonGraidentColor3.cgColor] as CFArray, locations: [0, 0.5, 0.5, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(callButtonGraident,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundPath = UIBezierPath(rect: CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5)))
            dialPadCallPressedFill.setFill()
            pressedBackgroundPath.fill()
        }


        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.99500 * group.height))
        bezier3Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 0.00000 * group.height))
        bezier4Path.addLine(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 1.00000 * group.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.00501 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.99692 * group.width, y: group.minY + 0.00501 * group.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        bezier2Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.00500 * group.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()




        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: group.minX + 0.58481 * group.width, y: group.minY + 0.72000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.58452 * group.width, y: group.minY + 0.72000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.58471 * group.width, y: group.minY + 0.72000 * group.height), controlPoint2: CGPoint(x: group.minX + 0.58462 * group.width, y: group.minY + 0.72000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.44675 * group.width, y: group.minY + 0.58398 * group.height), controlPoint1: CGPoint(x: group.minX + 0.53827 * group.width, y: group.minY + 0.71754 * group.height), controlPoint2: CGPoint(x: group.minX + 0.48409 * group.width, y: group.minY + 0.64469 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.36310 * group.width, y: group.minY + 0.36039 * group.height), controlPoint1: CGPoint(x: group.minX + 0.40938 * group.width, y: group.minY + 0.52328 * group.height), controlPoint2: CGPoint(x: group.minX + 0.36454 * group.width, y: group.minY + 0.43520 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.40262 * group.width, y: group.minY + 0.28699 * group.height), controlPoint1: CGPoint(x: group.minX + 0.36257 * group.width, y: group.minY + 0.33414 * group.height), controlPoint2: CGPoint(x: group.minX + 0.40221 * group.width, y: group.minY + 0.28746 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.42901 * group.width, y: group.minY + 0.29004 * group.height), controlPoint1: CGPoint(x: group.minX + 0.41291 * group.width, y: group.minY + 0.27535 * group.height), controlPoint2: CGPoint(x: group.minX + 0.42433 * group.width, y: group.minY + 0.27949 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.46550 * group.width, y: group.minY + 0.37957 * group.height), controlPoint1: CGPoint(x: group.minX + 0.43219 * group.width, y: group.minY + 0.29719 * group.height), controlPoint2: CGPoint(x: group.minX + 0.46224 * group.width, y: group.minY + 0.37117 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.46416 * group.width, y: group.minY + 0.41426 * group.height), controlPoint1: CGPoint(x: group.minX + 0.46889 * group.width, y: group.minY + 0.38828 * group.height), controlPoint2: CGPoint(x: group.minX + 0.46839 * group.width, y: group.minY + 0.40125 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.45046 * group.width, y: group.minY + 0.45391 * group.height), controlPoint1: CGPoint(x: group.minX + 0.46183 * group.width, y: group.minY + 0.42148 * group.height), controlPoint2: CGPoint(x: group.minX + 0.45409 * group.width, y: group.minY + 0.44359 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.48613 * group.width, y: group.minY + 0.51996 * group.height), controlPoint1: CGPoint(x: group.minX + 0.45438 * group.width, y: group.minY + 0.46297 * group.height), controlPoint2: CGPoint(x: group.minX + 0.46474 * group.width, y: group.minY + 0.48520 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.52680 * group.width, y: group.minY + 0.57797 * group.height), controlPoint1: CGPoint(x: group.minX + 0.50755 * group.width, y: group.minY + 0.55473 * group.height), controlPoint2: CGPoint(x: group.minX + 0.52120 * group.width, y: group.minY + 0.57160 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.55120 * group.width, y: group.minY + 0.55570 * group.height), controlPoint1: CGPoint(x: group.minX + 0.53315 * group.width, y: group.minY + 0.57207 * group.height), controlPoint2: CGPoint(x: group.minX + 0.54675 * group.width, y: group.minY + 0.55949 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.57243 * group.width, y: group.minY + 0.55344 * group.height), controlPoint1: CGPoint(x: group.minX + 0.55909 * group.width, y: group.minY + 0.54891 * group.height), controlPoint2: CGPoint(x: group.minX + 0.56702 * group.width, y: group.minY + 0.54805 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.62755 * group.width, y: group.minY + 0.61273 * group.height), controlPoint1: CGPoint(x: group.minX + 0.57796 * group.width, y: group.minY + 0.55895 * group.height), controlPoint2: CGPoint(x: group.minX + 0.62337 * group.width, y: group.minY + 0.60801 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.63377 * group.width, y: group.minY + 0.63164 * group.height), controlPoint1: CGPoint(x: group.minX + 0.63106 * group.width, y: group.minY + 0.61676 * group.height), controlPoint2: CGPoint(x: group.minX + 0.63332 * group.width, y: group.minY + 0.62363 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.62947 * group.width, y: group.minY + 0.65574 * group.height), controlPoint1: CGPoint(x: group.minX + 0.63421 * group.width, y: group.minY + 0.63973 * group.height), controlPoint2: CGPoint(x: group.minX + 0.63267 * group.width, y: group.minY + 0.64828 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.58481 * group.width, y: group.minY + 0.72000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.62921 * group.width, y: group.minY + 0.65637 * group.height), controlPoint2: CGPoint(x: group.minX + 0.60082 * group.width, y: group.minY + 0.72000 * group.height))
        bezier5Path.close()
        dialPadForeground.setFill()
        bezier5Path.fill()
    }

    @objc dynamic public class func drawDialPadNumber02(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "2"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "ABC"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawDialPadContact(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), add: Bool = true, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group.minX + fastFloor(group.width * 0.00000 + 0.5), y: group.minY + fastFloor(group.height * 0.00000 + 0.5), width: fastFloor(group.width * 0.99692 + 0.5) - fastFloor(group.width * 0.00000 + 0.5), height: fastFloor(group.height * 1.00000 + 0.5) - fastFloor(group.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.99500 * group.height))
        bezier3Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 0.00000 * group.height))
        bezier4Path.addLine(to: CGPoint(x: group.minX + 0.99385 * group.width, y: group.minY + 1.00000 * group.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.00501 * group.height))
        bezierPath.addLine(to: CGPoint(x: group.minX + 0.99692 * group.width, y: group.minY + 0.00501 * group.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.99500 * group.height))
        bezier2Path.addLine(to: CGPoint(x: group.minX + 0.00308 * group.width, y: group.minY + 0.00500 * group.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()






        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: group.minX + 0.52882 * group.width, y: group.minY + 0.57715 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.52827 * group.width, y: group.minY + 0.53567 * group.height), controlPoint1: CGPoint(x: group.minX + 0.52791 * group.width, y: group.minY + 0.56125 * group.height), controlPoint2: CGPoint(x: group.minX + 0.52827 * group.width, y: group.minY + 0.55017 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.54216 * group.width, y: group.minY + 0.48753 * group.height), controlPoint1: CGPoint(x: group.minX + 0.53276 * group.width, y: group.minY + 0.53190 * group.height), controlPoint2: CGPoint(x: group.minX + 0.54082 * group.width, y: group.minY + 0.50785 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.55291 * group.width, y: group.minY + 0.45979 * group.height), controlPoint1: CGPoint(x: group.minX + 0.54570 * group.width, y: group.minY + 0.48707 * group.height), controlPoint2: CGPoint(x: group.minX + 0.55127 * group.width, y: group.minY + 0.48157 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.54815 * group.width, y: group.minY + 0.43944 * group.height), controlPoint1: CGPoint(x: group.minX + 0.55377 * group.width, y: group.minY + 0.44810 * group.height), controlPoint2: CGPoint(x: group.minX + 0.55029 * group.width, y: group.minY + 0.44152 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.52608 * group.width, y: group.minY + 0.31731 * group.height), controlPoint1: CGPoint(x: group.minX + 0.55389 * group.width, y: group.minY + 0.41177 * group.height), controlPoint2: CGPoint(x: group.minX + 0.56584 * group.width, y: group.minY + 0.32616 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.49788 * group.width, y: group.minY + 0.30000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.52197 * group.width, y: group.minY + 0.30581 * group.height), controlPoint2: CGPoint(x: group.minX + 0.51149 * group.width, y: group.minY + 0.30000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.44877 * group.width, y: group.minY + 0.43944 * group.height), controlPoint1: CGPoint(x: group.minX + 0.44339 * group.width, y: group.minY + 0.30162 * group.height), controlPoint2: CGPoint(x: group.minX + 0.43683 * group.width, y: group.minY + 0.36587 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.44401 * group.width, y: group.minY + 0.45979 * group.height), controlPoint1: CGPoint(x: group.minX + 0.44663 * group.width, y: group.minY + 0.44152 * group.height), controlPoint2: CGPoint(x: group.minX + 0.44315 * group.width, y: group.minY + 0.44810 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.45476 * group.width, y: group.minY + 0.48753 * group.height), controlPoint1: CGPoint(x: group.minX + 0.44567 * group.width, y: group.minY + 0.48157 * group.height), controlPoint2: CGPoint(x: group.minX + 0.45123 * group.width, y: group.minY + 0.48707 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.46899 * group.width, y: group.minY + 0.53567 * group.height), controlPoint1: CGPoint(x: group.minX + 0.45611 * group.width, y: group.minY + 0.50785 * group.height), controlPoint2: CGPoint(x: group.minX + 0.46447 * group.width, y: group.minY + 0.53190 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.46841 * group.width, y: group.minY + 0.57715 * group.height), controlPoint1: CGPoint(x: group.minX + 0.46899 * group.width, y: group.minY + 0.55017 * group.height), controlPoint2: CGPoint(x: group.minX + 0.46933 * group.width, y: group.minY + 0.56125 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.38154 * group.width, y: group.minY + 0.70000 * group.height), controlPoint1: CGPoint(x: group.minX + 0.45764 * group.width, y: group.minY + 0.62355 * group.height), controlPoint2: CGPoint(x: group.minX + 0.38490 * group.width, y: group.minY + 0.61050 * group.height))
        bezier5Path.addLine(to: CGPoint(x: group.minX + 0.61538 * group.width, y: group.minY + 0.70000 * group.height))
        bezier5Path.addCurve(to: CGPoint(x: group.minX + 0.52882 * group.width, y: group.minY + 0.57715 * group.height), controlPoint1: CGPoint(x: group.minX + 0.61202 * group.width, y: group.minY + 0.61050 * group.height), controlPoint2: CGPoint(x: group.minX + 0.53959 * group.width, y: group.minY + 0.62355 * group.height))
        bezier5Path.close()
        dialPadForeground.setFill()
        bezier5Path.fill()


        if (add) {
            //// Text 2 Drawing
            let text2Rect = CGRect(x: group.minX + fastFloor(group.width * 0.30769 + 0.5), y: group.minY + fastFloor(group.height * 0.34000 + 0.5), width: fastFloor(group.width * 0.44308 + 0.5) - fastFloor(group.width * 0.30769 + 0.5), height: fastFloor(group.height * 0.65000 + 0.5) - fastFloor(group.height * 0.34000 + 0.5))
            let text2TextContent = "+"
            let text2Style = NSMutableParagraphStyle()
            text2Style.alignment = .center
            let text2FontAttributes = [
                .font: UIFont.systemFont(ofSize: dialPadSubTextSize, weight: .heavy),
                .foregroundColor: dialPadForeground,
                .paragraphStyle: text2Style,
            ] as [NSAttributedString.Key: Any]

            let text2TextHeight: CGFloat = text2TextContent.boundingRect(with: CGSize(width: text2Rect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: text2FontAttributes, context: nil).height
            context.saveGState()
            context.clip(to: text2Rect)
            text2TextContent.draw(in: CGRect(x: text2Rect.minX, y: text2Rect.minY + (text2Rect.height - text2TextHeight) / 2, width: text2Rect.width, height: text2TextHeight), withAttributes: text2FontAttributes)
            context.restoreGState()
        }
    }

    @objc dynamic public class func drawActiveCallMute(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 192, height: 211), resizing: ResizingBehavior = .aspectFit, muteText: String = "Mute", pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 192, height: 211), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 192, y: resizedFrame.height / 211)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 192, resizedFrame.height / 211)


        //// Color Declarations
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedBackground = UIColor(red: 0.247, green: 0.247, blue: 0.247, alpha: 1.000)

        //// Shadow Declarations
        let activeCallIconDropShadow = NSShadow()
        activeCallIconDropShadow.shadowColor = UIColor.black
        activeCallIconDropShadow.shadowOffset = CGSize(width: 2, height: 2)
        activeCallIconDropShadow.shadowBlurRadius = 3

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 217, height: 236), cornerRadius: 20)
            activeCallButtonPressedBackground.setFill()
            pressedBackgroundPath.fill()
        }


        //// MuteMicrophone Drawing
        let muteMicrophonePath = UIBezierPath()
        muteMicrophonePath.move(to: CGPoint(x: 108, y: 65.76))
        muteMicrophonePath.addCurve(to: CGPoint(x: 108, y: 70.07), controlPoint1: CGPoint(x: 108, y: 65.76), controlPoint2: CGPoint(x: 108, y: 67.53))
        muteMicrophonePath.addCurve(to: CGPoint(x: 108, y: 88.24), controlPoint1: CGPoint(x: 108, y: 76.6), controlPoint2: CGPoint(x: 108, y: 88.24))
        muteMicrophonePath.addCurve(to: CGPoint(x: 106.95, y: 94.14), controlPoint1: CGPoint(x: 108, y: 90.45), controlPoint2: CGPoint(x: 107.63, y: 92.43))
        muteMicrophonePath.addCurve(to: CGPoint(x: 84.09, y: 57.78), controlPoint1: CGPoint(x: 98.86, y: 81.28), controlPoint2: CGPoint(x: 89.64, y: 66.6))
        muteMicrophonePath.addCurve(to: CGPoint(x: 85.61, y: 55.81), controlPoint1: CGPoint(x: 84.54, y: 57.06), controlPoint2: CGPoint(x: 85.05, y: 56.4))
        muteMicrophonePath.addCurve(to: CGPoint(x: 95, y: 52), controlPoint1: CGPoint(x: 87.98, y: 53.33), controlPoint2: CGPoint(x: 91.31, y: 52))
        muteMicrophonePath.addCurve(to: CGPoint(x: 108, y: 65.76), controlPoint1: CGPoint(x: 102.18, y: 52), controlPoint2: CGPoint(x: 108, y: 57.04))
        muteMicrophonePath.close()
        muteMicrophonePath.move(to: CGPoint(x: 88.98, y: 88.11))
        muteMicrophonePath.addCurve(to: CGPoint(x: 97.57, y: 101.78), controlPoint1: CGPoint(x: 91.87, y: 92.7), controlPoint2: CGPoint(x: 94.8, y: 97.36))
        muteMicrophonePath.addCurve(to: CGPoint(x: 95, y: 102), controlPoint1: CGPoint(x: 96.74, y: 101.92), controlPoint2: CGPoint(x: 95.88, y: 102))
        muteMicrophonePath.addCurve(to: CGPoint(x: 82, y: 88.24), controlPoint1: CGPoint(x: 87.82, y: 102), controlPoint2: CGPoint(x: 82, y: 96.96))
        muteMicrophonePath.addCurve(to: CGPoint(x: 82, y: 77), controlPoint1: CGPoint(x: 82, y: 88.24), controlPoint2: CGPoint(x: 82, y: 82.62))
        muteMicrophonePath.addCurve(to: CGPoint(x: 88.98, y: 88.11), controlPoint1: CGPoint(x: 84.22, y: 80.53), controlPoint2: CGPoint(x: 86.59, y: 84.3))
        muteMicrophonePath.close()
        muteMicrophonePath.move(to: CGPoint(x: 122.25, y: 79.15))
        muteMicrophonePath.addLine(to: CGPoint(x: 122.25, y: 81.39))
        muteMicrophonePath.addLine(to: CGPoint(x: 122.25, y: 88.69))
        muteMicrophonePath.addCurve(to: CGPoint(x: 114.89, y: 106.77), controlPoint1: CGPoint(x: 122.25, y: 95.57), controlPoint2: CGPoint(x: 119.43, y: 101.96))
        muteMicrophonePath.addCurve(to: CGPoint(x: 111, y: 100.59), controlPoint1: CGPoint(x: 113.68, y: 104.85), controlPoint2: CGPoint(x: 112.37, y: 102.77))
        muteMicrophonePath.addCurve(to: CGPoint(x: 115.06, y: 88.69), controlPoint1: CGPoint(x: 113.54, y: 97.3), controlPoint2: CGPoint(x: 115.06, y: 93.17))
        muteMicrophonePath.addLine(to: CGPoint(x: 115.06, y: 81.39))
        muteMicrophonePath.addLine(to: CGPoint(x: 115.06, y: 79.14))
        muteMicrophonePath.addLine(to: CGPoint(x: 122.25, y: 79.15))
        muteMicrophonePath.close()
        muteMicrophonePath.move(to: CGPoint(x: 76.07, y: 79.15))
        muteMicrophonePath.addCurve(to: CGPoint(x: 76.07, y: 81.39), controlPoint1: CGPoint(x: 76.07, y: 79.14), controlPoint2: CGPoint(x: 76.07, y: 81.39))
        muteMicrophonePath.addLine(to: CGPoint(x: 76.07, y: 88.69))
        muteMicrophonePath.addCurve(to: CGPoint(x: 95.56, y: 108.17), controlPoint1: CGPoint(x: 76.07, y: 99.45), controlPoint2: CGPoint(x: 84.8, y: 108.17))
        muteMicrophonePath.addCurve(to: CGPoint(x: 101.09, y: 107.38), controlPoint1: CGPoint(x: 97.48, y: 108.17), controlPoint2: CGPoint(x: 99.34, y: 107.9))
        muteMicrophonePath.addCurve(to: CGPoint(x: 104.98, y: 113.55), controlPoint1: CGPoint(x: 102.47, y: 109.56), controlPoint2: CGPoint(x: 103.77, y: 111.63))
        muteMicrophonePath.addCurve(to: CGPoint(x: 100.01, y: 115.02), controlPoint1: CGPoint(x: 103.38, y: 114.2), controlPoint2: CGPoint(x: 101.72, y: 114.69))
        muteMicrophonePath.addCurve(to: CGPoint(x: 100.01, y: 123.92), controlPoint1: CGPoint(x: 100.01, y: 115.02), controlPoint2: CGPoint(x: 100.01, y: 123.03))
        muteMicrophonePath.addCurve(to: CGPoint(x: 109.99, y: 123.92), controlPoint1: CGPoint(x: 100.34, y: 123.92), controlPoint2: CGPoint(x: 109.99, y: 123.92))
        muteMicrophonePath.addCurve(to: CGPoint(x: 111.66, y: 124.19), controlPoint1: CGPoint(x: 110.57, y: 123.92), controlPoint2: CGPoint(x: 111.13, y: 124.01))
        muteMicrophonePath.addCurve(to: CGPoint(x: 112.92, y: 126.19), controlPoint1: CGPoint(x: 112.47, y: 125.48), controlPoint2: CGPoint(x: 112.92, y: 126.19))
        muteMicrophonePath.addLine(to: CGPoint(x: 115.05, y: 129.58))
        muteMicrophonePath.addCurve(to: CGPoint(x: 115.3, y: 129.42), controlPoint1: CGPoint(x: 115.05, y: 129.58), controlPoint2: CGPoint(x: 115.14, y: 129.52))
        muteMicrophonePath.addCurve(to: CGPoint(x: 115.27, y: 129.91), controlPoint1: CGPoint(x: 115.29, y: 129.63), controlPoint2: CGPoint(x: 115.27, y: 129.91))
        muteMicrophonePath.addLine(to: CGPoint(x: 75.54, y: 130))
        muteMicrophonePath.addLine(to: CGPoint(x: 75.59, y: 129.19))
        muteMicrophonePath.addCurve(to: CGPoint(x: 80.91, y: 123.92), controlPoint1: CGPoint(x: 75.59, y: 126.3), controlPoint2: CGPoint(x: 77.97, y: 123.92))
        muteMicrophonePath.addLine(to: CGPoint(x: 90.99, y: 123.92))
        muteMicrophonePath.addCurve(to: CGPoint(x: 90.99, y: 115.02), controlPoint1: CGPoint(x: 90.99, y: 123.03), controlPoint2: CGPoint(x: 90.99, y: 115.02))
        muteMicrophonePath.addCurve(to: CGPoint(x: 68.88, y: 88.69), controlPoint1: CGPoint(x: 78.54, y: 112.62), controlPoint2: CGPoint(x: 68.88, y: 101.5))
        muteMicrophonePath.addLine(to: CGPoint(x: 68.88, y: 81.39))
        muteMicrophonePath.addLine(to: CGPoint(x: 68.88, y: 79.14))
        muteMicrophonePath.addLine(to: CGPoint(x: 76.07, y: 79.14))
        muteMicrophonePath.addLine(to: CGPoint(x: 76.07, y: 79.15))
        muteMicrophonePath.close()
        muteMicrophonePath.move(to: CGPoint(x: 75.69, y: 51.94))
        muteMicrophonePath.addLine(to: CGPoint(x: 119.69, y: 121.94))
        muteMicrophonePath.addLine(to: CGPoint(x: 116.31, y: 124.06))
        muteMicrophonePath.addLine(to: CGPoint(x: 72.31, y: 54.06))
        muteMicrophonePath.addLine(to: CGPoint(x: 75.69, y: 51.94))
        muteMicrophonePath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: activeCallIconDropShadow.shadowOffset.width * resizedShadowScale, height: activeCallIconDropShadow.shadowOffset.height * resizedShadowScale), blur: activeCallIconDropShadow.shadowBlurRadius * resizedShadowScale, color: (activeCallIconDropShadow.shadowColor as! UIColor).cgColor)
        activeCallButtonStroke.setFill()
        muteMicrophonePath.fill()
        context.restoreGState()



        //// Text Drawing
        let textRect = CGRect(x: 0, y: 162, width: 192, height: 35)
        let textStyle = NSMutableParagraphStyle()
        textStyle.alignment = .center
        let textFontAttributes = [
            .font: UIFont.systemFont(ofSize: 32),
            .foregroundColor: activeCallButtonStroke,
            .paragraphStyle: textStyle,
        ] as [NSAttributedString.Key: Any]

        let textTextHeight: CGFloat = muteText.boundingRect(with: CGSize(width: textRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: textFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: textRect)
        muteText.draw(in: CGRect(x: textRect.minX, y: textRect.minY + (textRect.height - textTextHeight) / 2, width: textRect.width, height: textTextHeight), withAttributes: textFontAttributes)
        context.restoreGState()


        //// Outline
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 192, y: 0))
        bezierPath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bottom Drawing
        let bottomPath = UIBezierPath()
        bottomPath.move(to: CGPoint(x: 0, y: 211))
        bottomPath.addLine(to: CGPoint(x: 192, y: 211))
        activeCallButtonStroke.setStroke()
        bottomPath.lineWidth = 1
        bottomPath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawDialPadNumber07(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "7"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "PQRS"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButtonStar(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundPath = UIBezierPath(roundedRect: CGRect(x: frame.minX, y: frame.minY - 25, width: 185, height: 131), cornerRadius: 20)
            activeCallButtonBackground.setFill()
            normalBackgroundPath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY - 25, width: 185, height: 131)
            let pressedBackgroundPath = UIBezierPath(roundedRect: pressedBackgroundRect, cornerRadius: 20)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Grid
        //// RightGrid Drawing
        let rightGridPath = UIBezierPath()
        rightGridPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        rightGridPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        rightGridPath.lineWidth = 1
        rightGridPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 0))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()




        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: frame.minX + 82, y: frame.minY + 62))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 78, y: frame.minY + 62))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 77, y: frame.minY + 61), controlPoint1: CGPoint(x: frame.minX + 77.45, y: frame.minY + 62), controlPoint2: CGPoint(x: frame.minX + 77, y: frame.minY + 61.55))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 77, y: frame.minY + 48.22))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 65.9, y: frame.minY + 54.57))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 64.54, y: frame.minY + 54.21), controlPoint1: CGPoint(x: frame.minX + 65.42, y: frame.minY + 54.84), controlPoint2: CGPoint(x: frame.minX + 64.82, y: frame.minY + 54.68))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 62.54, y: frame.minY + 50.81))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 62.43, y: frame.minY + 50.05), controlPoint1: CGPoint(x: frame.minX + 62.4, y: frame.minY + 50.58), controlPoint2: CGPoint(x: frame.minX + 62.36, y: frame.minY + 50.3))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 62.9, y: frame.minY + 49.44), controlPoint1: CGPoint(x: frame.minX + 62.5, y: frame.minY + 49.79), controlPoint2: CGPoint(x: frame.minX + 62.67, y: frame.minY + 49.57))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 74, y: frame.minY + 43))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 62.9, y: frame.minY + 36.57))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 62.43, y: frame.minY + 35.95), controlPoint1: CGPoint(x: frame.minX + 62.67, y: frame.minY + 36.43), controlPoint2: CGPoint(x: frame.minX + 62.5, y: frame.minY + 36.21))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 62.54, y: frame.minY + 35.19), controlPoint1: CGPoint(x: frame.minX + 62.36, y: frame.minY + 35.7), controlPoint2: CGPoint(x: frame.minX + 62.4, y: frame.minY + 35.42))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 64.54, y: frame.minY + 31.79))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 65.9, y: frame.minY + 31.43), controlPoint1: CGPoint(x: frame.minX + 64.81, y: frame.minY + 31.32), controlPoint2: CGPoint(x: frame.minX + 65.42, y: frame.minY + 31.16))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 77, y: frame.minY + 37.78))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 77, y: frame.minY + 25))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 78, y: frame.minY + 24), controlPoint1: CGPoint(x: frame.minX + 77, y: frame.minY + 24.45), controlPoint2: CGPoint(x: frame.minX + 77.45, y: frame.minY + 24))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 82, y: frame.minY + 24))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 83, y: frame.minY + 25), controlPoint1: CGPoint(x: frame.minX + 82.56, y: frame.minY + 24), controlPoint2: CGPoint(x: frame.minX + 83, y: frame.minY + 24.45))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 83, y: frame.minY + 37.78))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 94.11, y: frame.minY + 31.43))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 95.46, y: frame.minY + 31.79), controlPoint1: CGPoint(x: frame.minX + 94.58, y: frame.minY + 31.16), controlPoint2: CGPoint(x: frame.minX + 95.18, y: frame.minY + 31.32))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 97.46, y: frame.minY + 35.19))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 97.57, y: frame.minY + 35.95), controlPoint1: CGPoint(x: frame.minX + 97.6, y: frame.minY + 35.42), controlPoint2: CGPoint(x: frame.minX + 97.64, y: frame.minY + 35.7))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 97.1, y: frame.minY + 36.57), controlPoint1: CGPoint(x: frame.minX + 97.5, y: frame.minY + 36.21), controlPoint2: CGPoint(x: frame.minX + 97.33, y: frame.minY + 36.43))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 86, y: frame.minY + 43))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 97.1, y: frame.minY + 49.43))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 97.57, y: frame.minY + 50.05), controlPoint1: CGPoint(x: frame.minX + 97.33, y: frame.minY + 49.57), controlPoint2: CGPoint(x: frame.minX + 97.5, y: frame.minY + 49.79))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 97.46, y: frame.minY + 50.81), controlPoint1: CGPoint(x: frame.minX + 97.63, y: frame.minY + 50.3), controlPoint2: CGPoint(x: frame.minX + 97.6, y: frame.minY + 50.58))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 95.46, y: frame.minY + 54.21))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 94.11, y: frame.minY + 54.57), controlPoint1: CGPoint(x: frame.minX + 95.18, y: frame.minY + 54.68), controlPoint2: CGPoint(x: frame.minX + 94.58, y: frame.minY + 54.84))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 83, y: frame.minY + 48.22))
        bezier5Path.addLine(to: CGPoint(x: frame.minX + 83, y: frame.minY + 61))
        bezier5Path.addCurve(to: CGPoint(x: frame.minX + 82, y: frame.minY + 62), controlPoint1: CGPoint(x: frame.minX + 83, y: frame.minY + 61.55), controlPoint2: CGPoint(x: frame.minX + 82.56, y: frame.minY + 62))
        bezier5Path.close()
        dialPadForeground.setFill()
        bezier5Path.fill()
    }

    @objc dynamic public class func drawActiveCallButton08(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "TUV"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "8"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridRight Drawing
        let gridRightPath = UIBezierPath()
        gridRightPath.move(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        gridRightPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridRightPath.lineWidth = 1
        gridRightPath.stroke()


        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()


        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawDialPadNumber04(frame: CGRect = CGRect(x: 0, y: 0, width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let dialPadButtonGradientColor2 = UIColor(red: 0.337, green: 0.337, blue: 0.337, alpha: 1.000)
        let dialButtonLowLight = UIColor(red: 0.275, green: 0.275, blue: 0.275, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let dialButtonHighlight = UIColor(red: 0.584, green: 0.584, blue: 0.584, alpha: 1.000)
        let dialPadButtonGradientColor = UIColor(red: 0.486, green: 0.486, blue: 0.486, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!
        let dialPadButtonGradient = CGGradient(colorsSpace: nil, colors: [dialPadButtonGradientColor.cgColor, dialPadButtonGradientColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2


        //// Subframes
        let group2: CGRect = CGRect(x: frame.minX, y: frame.minY, width: fastFloor((frame.width) * 1.00309) + 0.5, height: fastFloor((frame.height) * 1.00000 + 0.5))


        //// Group 2
        if (notPressed) {
            //// NormalBackground Drawing
            let normalBackgroundRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let normalBackgroundPath = UIBezierPath(rect: normalBackgroundRect)
            context.saveGState()
            normalBackgroundPath.addClip()
            context.drawLinearGradient(dialPadButtonGradient,
                start: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.minY),
                end: CGPoint(x: normalBackgroundRect.midX, y: normalBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        if (pressed2) {
            //// PressedBackgrond Drawing
            let pressedBackgrondRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 1.00000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
            let pressedBackgrondPath = UIBezierPath(rect: pressedBackgrondRect)
            context.saveGState()
            pressedBackgrondPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.minY),
                end: CGPoint(x: pressedBackgrondRect.midX, y: pressedBackgrondRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// MainText Drawing
        let mainTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.00000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.68000 + 0.5) - fastFloor(group2.height * 0.00000 + 0.5))
        let mainTextTextContent = "4"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadMainTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()


        //// SubText Drawing
        let subTextRect = CGRect(x: group2.minX + fastFloor(group2.width * 0.00000 + 0.5), y: group2.minY + fastFloor(group2.height * 0.58000 + 0.5), width: fastFloor(group2.width * 0.99692 + 0.5) - fastFloor(group2.width * 0.00000 + 0.5), height: fastFloor(group2.height * 0.90000 + 0.5) - fastFloor(group2.height * 0.58000 + 0.5))
        let subTextTextContent = "GHI"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: dialPadSubTextSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()




        //// Outline
        //// LowLight
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier3Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        dialButtonLowLight.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.stroke()


        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 0.00000 * group2.height))
        bezier4Path.addLine(to: CGPoint(x: group2.minX + 0.99385 * group2.width, y: group2.minY + 1.00000 * group2.height))
        dialButtonLowLight.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.stroke()




        //// Highlight
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.00501 * group2.height))
        bezierPath.addLine(to: CGPoint(x: group2.minX + 0.99692 * group2.width, y: group2.minY + 0.00501 * group2.height))
        dialButtonHighlight.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.99500 * group2.height))
        bezier2Path.addLine(to: CGPoint(x: group2.minX + 0.00308 * group2.width, y: group2.minY + 0.00500 * group2.height))
        dialButtonHighlight.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.stroke()
    }

    @objc dynamic public class func drawActiveCallButton06(frame: CGRect = CGRect(x: 0, y: 0, width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let activeCallButtonPressedGraidentColor = UIColor(red: 0.369, green: 0.573, blue: 0.776, alpha: 1.000)
        let dialPadForeground = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let activeCallButtonPressedGraidentColor2 = UIColor(red: 0.271, green: 0.408, blue: 0.561, alpha: 1.000)
        let activeCallButtonBackground = UIColor(red: 0.357, green: 0.357, blue: 0.357, alpha: 1.000)
        let activeCallButtonStroke = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let activeCallButtonPressedGraident = CGGradient(colorsSpace: nil, colors: [activeCallButtonPressedGraidentColor.cgColor, activeCallButtonPressedGraidentColor2.cgColor] as CFArray, locations: [0, 1])!

        //// Variable Declarations
        let notPressed = !pressed2

        //// Group
        if (notPressed) {
            //// Rectangle Drawing
            let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106))
            activeCallButtonBackground.setFill()
            rectanglePath.fill()
        }


        if (pressed2) {
            //// PressedBackground Drawing
            let pressedBackgroundRect = CGRect(x: frame.minX, y: frame.minY, width: 160, height: 106)
            let pressedBackgroundPath = UIBezierPath(rect: pressedBackgroundRect)
            context.saveGState()
            pressedBackgroundPath.addClip()
            context.drawLinearGradient(activeCallButtonPressedGraident,
                start: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.minY),
                end: CGPoint(x: pressedBackgroundRect.midX, y: pressedBackgroundRect.maxY),
                options: [])
            context.restoreGState()
        }


        //// Text
        //// SubText Drawing
        let subTextRect = CGRect(x: frame.minX, y: frame.minY + 68, width: 160, height: 32)
        let subTextTextContent = "MNO"
        let subTextStyle = NSMutableParagraphStyle()
        subTextStyle.alignment = .center
        let subTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallSubTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: subTextStyle,
        ] as [NSAttributedString.Key: Any]

        let subTextTextHeight: CGFloat = subTextTextContent.boundingRect(with: CGSize(width: subTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: subTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: subTextRect)
        subTextTextContent.draw(in: CGRect(x: subTextRect.minX, y: subTextRect.minY + (subTextRect.height - subTextTextHeight) / 2, width: subTextRect.width, height: subTextTextHeight), withAttributes: subTextFontAttributes)
        context.restoreGState()


        //// MainText Drawing
        let mainTextRect = CGRect(x: frame.minX, y: frame.minY + 7, width: 160, height: 72)
        let mainTextTextContent = "6"
        let mainTextStyle = NSMutableParagraphStyle()
        mainTextStyle.alignment = .center
        let mainTextFontAttributes = [
            .font: UIFont.systemFont(ofSize: activeCallMainTextFontSize),
            .foregroundColor: dialPadForeground,
            .paragraphStyle: mainTextStyle,
        ] as [NSAttributedString.Key: Any]

        let mainTextTextHeight: CGFloat = mainTextTextContent.boundingRect(with: CGSize(width: mainTextRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: mainTextFontAttributes, context: nil).height
        context.saveGState()
        context.clip(to: mainTextRect)
        mainTextTextContent.draw(in: CGRect(x: mainTextRect.minX, y: mainTextRect.minY + (mainTextRect.height - mainTextTextHeight) / 2, width: mainTextRect.width, height: mainTextTextHeight), withAttributes: mainTextFontAttributes)
        context.restoreGState()




        //// Grid
        //// GridTop Drawing
        let gridTopPath = UIBezierPath()
        gridTopPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 0))
        gridTopPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY))
        activeCallButtonStroke.setStroke()
        gridTopPath.lineWidth = 1
        gridTopPath.stroke()


        //// GridLeft Drawing
        let gridLeftPath = UIBezierPath()
        gridLeftPath.move(to: CGPoint(x: frame.minX, y: frame.minY))
        gridLeftPath.addLine(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridLeftPath.lineWidth = 1
        gridLeftPath.stroke()


        //// GridBottom Drawing
        let gridBottomPath = UIBezierPath()
        gridBottomPath.move(to: CGPoint(x: frame.minX, y: frame.minY + 106))
        gridBottomPath.addLine(to: CGPoint(x: frame.minX + 160, y: frame.minY + 106))
        activeCallButtonStroke.setStroke()
        gridBottomPath.lineWidth = 1
        gridBottomPath.stroke()
    }

    @objc dynamic public class func drawRoundButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 44, height: 44), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 44, height: 44), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 44, y: resizedFrame.height / 44)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 44, resizedFrame.height / 44)


        //// Color Declarations
        let tabBarFill = UIColor(red: 0.502, green: 0.502, blue: 0.502, alpha: 1.000)
        let buttonFillTop = UIColor(red: 0.941, green: 0.941, blue: 0.941, alpha: 1.000)
        let buttonFillBottom = UIColor(red: 0.882, green: 0.886, blue: 0.900, alpha: 1.000)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black
        shadow.shadowOffset = CGSize(width: 0, height: 0)
        shadow.shadowBlurRadius = 1

        //// ShadowBackground Drawing
        let shadowBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 1, y: 1, width: 42, height: 42), cornerRadius: 10)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        UIColor.gray.setFill()
        shadowBackgroundPath.fill()
        context.restoreGState()



        //// BottomFill Drawing
        let bottomFillPath = UIBezierPath()
        bottomFillPath.move(to: CGPoint(x: 43, y: 27.68))
        bottomFillPath.addCurve(to: CGPoint(x: 42.35, y: 36.3), controlPoint1: CGPoint(x: 43, y: 32.12), controlPoint2: CGPoint(x: 43, y: 34.32))
        bottomFillPath.addLine(to: CGPoint(x: 42.25, y: 36.69))
        bottomFillPath.addCurve(to: CGPoint(x: 36.69, y: 42.25), controlPoint1: CGPoint(x: 41.31, y: 39.27), controlPoint2: CGPoint(x: 39.27, y: 41.31))
        bottomFillPath.addCurve(to: CGPoint(x: 27.71, y: 43), controlPoint1: CGPoint(x: 34.32, y: 43), controlPoint2: CGPoint(x: 32.12, y: 43))
        bottomFillPath.addLine(to: CGPoint(x: 16.29, y: 43))
        bottomFillPath.addCurve(to: CGPoint(x: 7.7, y: 42.35), controlPoint1: CGPoint(x: 11.88, y: 43), controlPoint2: CGPoint(x: 9.68, y: 43))
        bottomFillPath.addLine(to: CGPoint(x: 7.31, y: 42.25))
        bottomFillPath.addCurve(to: CGPoint(x: 1.75, y: 36.69), controlPoint1: CGPoint(x: 4.73, y: 41.31), controlPoint2: CGPoint(x: 2.69, y: 39.27))
        bottomFillPath.addCurve(to: CGPoint(x: 1, y: 27.71), controlPoint1: CGPoint(x: 1, y: 34.32), controlPoint2: CGPoint(x: 1, y: 32.12))
        bottomFillPath.addCurve(to: CGPoint(x: 1, y: 22), controlPoint1: CGPoint(x: 1, y: 27.71), controlPoint2: CGPoint(x: 1, y: 24.86))
        bottomFillPath.addLine(to: CGPoint(x: 43, y: 22))
        bottomFillPath.addCurve(to: CGPoint(x: 43, y: 27.71), controlPoint1: CGPoint(x: 43, y: 24.86), controlPoint2: CGPoint(x: 43, y: 27.71))
        bottomFillPath.addLine(to: CGPoint(x: 43, y: 27.68))
        bottomFillPath.close()
        buttonFillBottom.setFill()
        bottomFillPath.fill()


        //// TopFill Drawing
        let topFillPath = UIBezierPath()
        topFillPath.move(to: CGPoint(x: 36.3, y: 1.65))
        topFillPath.addLine(to: CGPoint(x: 36.69, y: 1.75))
        topFillPath.addCurve(to: CGPoint(x: 42.25, y: 7.31), controlPoint1: CGPoint(x: 39.27, y: 2.69), controlPoint2: CGPoint(x: 41.31, y: 4.73))
        topFillPath.addCurve(to: CGPoint(x: 43, y: 16.29), controlPoint1: CGPoint(x: 43, y: 9.68), controlPoint2: CGPoint(x: 43, y: 11.88))
        topFillPath.addCurve(to: CGPoint(x: 43, y: 22), controlPoint1: CGPoint(x: 43, y: 16.29), controlPoint2: CGPoint(x: 43, y: 19.14))
        topFillPath.addLine(to: CGPoint(x: 1, y: 22))
        topFillPath.addCurve(to: CGPoint(x: 1, y: 16.29), controlPoint1: CGPoint(x: 1, y: 19.14), controlPoint2: CGPoint(x: 1, y: 16.29))
        topFillPath.addCurve(to: CGPoint(x: 1.65, y: 7.7), controlPoint1: CGPoint(x: 1, y: 11.88), controlPoint2: CGPoint(x: 1, y: 9.68))
        topFillPath.addLine(to: CGPoint(x: 1.75, y: 7.31))
        topFillPath.addCurve(to: CGPoint(x: 7.31, y: 1.75), controlPoint1: CGPoint(x: 2.69, y: 4.73), controlPoint2: CGPoint(x: 4.73, y: 2.69))
        topFillPath.addCurve(to: CGPoint(x: 16.29, y: 1), controlPoint1: CGPoint(x: 9.68, y: 1), controlPoint2: CGPoint(x: 11.88, y: 1))
        topFillPath.addLine(to: CGPoint(x: 27.71, y: 1))
        topFillPath.addCurve(to: CGPoint(x: 36.3, y: 1.65), controlPoint1: CGPoint(x: 32.12, y: 1), controlPoint2: CGPoint(x: 34.32, y: 1))
        topFillPath.close()
        buttonFillTop.setFill()
        topFillPath.fill()


        //// Outline Drawing
        let outlinePath = UIBezierPath()
        outlinePath.move(to: CGPoint(x: 16.35, y: 1.25))
        outlinePath.addLine(to: CGPoint(x: 27.65, y: 1.25))
        outlinePath.addCurve(to: CGPoint(x: 36.13, y: 1.9), controlPoint1: CGPoint(x: 31.99, y: 1.25), controlPoint2: CGPoint(x: 34.17, y: 1.25))
        outlinePath.addLine(to: CGPoint(x: 36.51, y: 1.99))
        outlinePath.addCurve(to: CGPoint(x: 42.01, y: 7.49), controlPoint1: CGPoint(x: 39.07, y: 2.92), controlPoint2: CGPoint(x: 41.08, y: 4.93))
        outlinePath.addCurve(to: CGPoint(x: 42.75, y: 16.35), controlPoint1: CGPoint(x: 42.75, y: 9.83), controlPoint2: CGPoint(x: 42.75, y: 12.01))
        outlinePath.addLine(to: CGPoint(x: 42.75, y: 27.65))
        outlinePath.addCurve(to: CGPoint(x: 42.1, y: 36.13), controlPoint1: CGPoint(x: 42.75, y: 31.99), controlPoint2: CGPoint(x: 42.75, y: 34.17))
        outlinePath.addLine(to: CGPoint(x: 42.01, y: 36.51))
        outlinePath.addCurve(to: CGPoint(x: 36.51, y: 42.01), controlPoint1: CGPoint(x: 41.08, y: 39.07), controlPoint2: CGPoint(x: 39.07, y: 41.08))
        outlinePath.addCurve(to: CGPoint(x: 27.65, y: 42.75), controlPoint1: CGPoint(x: 34.17, y: 42.75), controlPoint2: CGPoint(x: 31.99, y: 42.75))
        outlinePath.addLine(to: CGPoint(x: 16.35, y: 42.75))
        outlinePath.addCurve(to: CGPoint(x: 7.87, y: 42.1), controlPoint1: CGPoint(x: 12.01, y: 42.75), controlPoint2: CGPoint(x: 9.83, y: 42.75))
        outlinePath.addLine(to: CGPoint(x: 7.49, y: 42.01))
        outlinePath.addCurve(to: CGPoint(x: 1.99, y: 36.51), controlPoint1: CGPoint(x: 4.93, y: 41.08), controlPoint2: CGPoint(x: 2.92, y: 39.07))
        outlinePath.addCurve(to: CGPoint(x: 1.25, y: 27.65), controlPoint1: CGPoint(x: 1.25, y: 34.17), controlPoint2: CGPoint(x: 1.25, y: 31.99))
        outlinePath.addLine(to: CGPoint(x: 1.25, y: 16.35))
        outlinePath.addCurve(to: CGPoint(x: 1.9, y: 7.87), controlPoint1: CGPoint(x: 1.25, y: 12.01), controlPoint2: CGPoint(x: 1.25, y: 9.83))
        outlinePath.addLine(to: CGPoint(x: 1.99, y: 7.49))
        outlinePath.addCurve(to: CGPoint(x: 7.49, y: 1.99), controlPoint1: CGPoint(x: 2.92, y: 4.93), controlPoint2: CGPoint(x: 4.93, y: 2.92))
        outlinePath.addCurve(to: CGPoint(x: 16.35, y: 1.25), controlPoint1: CGPoint(x: 9.83, y: 1.25), controlPoint2: CGPoint(x: 12.01, y: 1.25))
        outlinePath.close()
        tabBarFill.setStroke()
        outlinePath.lineWidth = 1
        outlinePath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawSOSRoundButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 44, height: 44), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 44, height: 44), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 44, y: resizedFrame.height / 44)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 44, resizedFrame.height / 44)


        //// Color Declarations
        let sOSButtonBottomFill = UIColor(red: 0.922, green: 0.216, blue: 0.071, alpha: 1.000)
        let tabBarFill = UIColor(red: 0.502, green: 0.502, blue: 0.502, alpha: 1.000)
        let sOSButtonTopFill = UIColor(red: 0.945, green: 0.392, blue: 0.424, alpha: 1.000)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black
        shadow.shadowOffset = CGSize(width: 0, height: 0)
        shadow.shadowBlurRadius = 1

        //// ShadowBackground Drawing
        let shadowBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 1, y: 1, width: 42, height: 42), cornerRadius: 10)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        UIColor.gray.setFill()
        shadowBackgroundPath.fill()
        context.restoreGState()



        //// BottomFill Drawing
        let bottomFillPath = UIBezierPath()
        bottomFillPath.move(to: CGPoint(x: 43, y: 27.68))
        bottomFillPath.addCurve(to: CGPoint(x: 42.35, y: 36.3), controlPoint1: CGPoint(x: 43, y: 32.12), controlPoint2: CGPoint(x: 43, y: 34.32))
        bottomFillPath.addLine(to: CGPoint(x: 42.25, y: 36.69))
        bottomFillPath.addCurve(to: CGPoint(x: 36.69, y: 42.25), controlPoint1: CGPoint(x: 41.31, y: 39.27), controlPoint2: CGPoint(x: 39.27, y: 41.31))
        bottomFillPath.addCurve(to: CGPoint(x: 27.71, y: 43), controlPoint1: CGPoint(x: 34.32, y: 43), controlPoint2: CGPoint(x: 32.12, y: 43))
        bottomFillPath.addLine(to: CGPoint(x: 16.29, y: 43))
        bottomFillPath.addCurve(to: CGPoint(x: 7.7, y: 42.35), controlPoint1: CGPoint(x: 11.88, y: 43), controlPoint2: CGPoint(x: 9.68, y: 43))
        bottomFillPath.addLine(to: CGPoint(x: 7.31, y: 42.25))
        bottomFillPath.addCurve(to: CGPoint(x: 1.75, y: 36.69), controlPoint1: CGPoint(x: 4.73, y: 41.31), controlPoint2: CGPoint(x: 2.69, y: 39.27))
        bottomFillPath.addCurve(to: CGPoint(x: 1, y: 27.71), controlPoint1: CGPoint(x: 1, y: 34.32), controlPoint2: CGPoint(x: 1, y: 32.12))
        bottomFillPath.addCurve(to: CGPoint(x: 1, y: 22), controlPoint1: CGPoint(x: 1, y: 27.71), controlPoint2: CGPoint(x: 1, y: 24.86))
        bottomFillPath.addLine(to: CGPoint(x: 43, y: 22))
        bottomFillPath.addCurve(to: CGPoint(x: 43, y: 27.71), controlPoint1: CGPoint(x: 43, y: 24.86), controlPoint2: CGPoint(x: 43, y: 27.71))
        bottomFillPath.addLine(to: CGPoint(x: 43, y: 27.68))
        bottomFillPath.close()
        sOSButtonBottomFill.setFill()
        bottomFillPath.fill()


        //// TopFill Drawing
        let topFillPath = UIBezierPath()
        topFillPath.move(to: CGPoint(x: 36.3, y: 1.65))
        topFillPath.addLine(to: CGPoint(x: 36.69, y: 1.75))
        topFillPath.addCurve(to: CGPoint(x: 42.25, y: 7.31), controlPoint1: CGPoint(x: 39.27, y: 2.69), controlPoint2: CGPoint(x: 41.31, y: 4.73))
        topFillPath.addCurve(to: CGPoint(x: 43, y: 16.29), controlPoint1: CGPoint(x: 43, y: 9.68), controlPoint2: CGPoint(x: 43, y: 11.88))
        topFillPath.addCurve(to: CGPoint(x: 43, y: 22), controlPoint1: CGPoint(x: 43, y: 16.29), controlPoint2: CGPoint(x: 43, y: 19.14))
        topFillPath.addLine(to: CGPoint(x: 1, y: 22))
        topFillPath.addCurve(to: CGPoint(x: 1, y: 16.29), controlPoint1: CGPoint(x: 1, y: 19.14), controlPoint2: CGPoint(x: 1, y: 16.29))
        topFillPath.addCurve(to: CGPoint(x: 1.65, y: 7.7), controlPoint1: CGPoint(x: 1, y: 11.88), controlPoint2: CGPoint(x: 1, y: 9.68))
        topFillPath.addLine(to: CGPoint(x: 1.75, y: 7.31))
        topFillPath.addCurve(to: CGPoint(x: 7.31, y: 1.75), controlPoint1: CGPoint(x: 2.69, y: 4.73), controlPoint2: CGPoint(x: 4.73, y: 2.69))
        topFillPath.addCurve(to: CGPoint(x: 16.29, y: 1), controlPoint1: CGPoint(x: 9.68, y: 1), controlPoint2: CGPoint(x: 11.88, y: 1))
        topFillPath.addLine(to: CGPoint(x: 27.71, y: 1))
        topFillPath.addCurve(to: CGPoint(x: 36.3, y: 1.65), controlPoint1: CGPoint(x: 32.12, y: 1), controlPoint2: CGPoint(x: 34.32, y: 1))
        topFillPath.close()
        sOSButtonTopFill.setFill()
        topFillPath.fill()


        //// Outline Drawing
        let outlinePath = UIBezierPath()
        outlinePath.move(to: CGPoint(x: 16.35, y: 1.25))
        outlinePath.addLine(to: CGPoint(x: 27.65, y: 1.25))
        outlinePath.addCurve(to: CGPoint(x: 36.13, y: 1.9), controlPoint1: CGPoint(x: 31.99, y: 1.25), controlPoint2: CGPoint(x: 34.17, y: 1.25))
        outlinePath.addLine(to: CGPoint(x: 36.51, y: 1.99))
        outlinePath.addCurve(to: CGPoint(x: 42.01, y: 7.49), controlPoint1: CGPoint(x: 39.07, y: 2.92), controlPoint2: CGPoint(x: 41.08, y: 4.93))
        outlinePath.addCurve(to: CGPoint(x: 42.75, y: 16.35), controlPoint1: CGPoint(x: 42.75, y: 9.83), controlPoint2: CGPoint(x: 42.75, y: 12.01))
        outlinePath.addLine(to: CGPoint(x: 42.75, y: 27.65))
        outlinePath.addCurve(to: CGPoint(x: 42.1, y: 36.13), controlPoint1: CGPoint(x: 42.75, y: 31.99), controlPoint2: CGPoint(x: 42.75, y: 34.17))
        outlinePath.addLine(to: CGPoint(x: 42.01, y: 36.51))
        outlinePath.addCurve(to: CGPoint(x: 36.51, y: 42.01), controlPoint1: CGPoint(x: 41.08, y: 39.07), controlPoint2: CGPoint(x: 39.07, y: 41.08))
        outlinePath.addCurve(to: CGPoint(x: 27.65, y: 42.75), controlPoint1: CGPoint(x: 34.17, y: 42.75), controlPoint2: CGPoint(x: 31.99, y: 42.75))
        outlinePath.addLine(to: CGPoint(x: 16.35, y: 42.75))
        outlinePath.addCurve(to: CGPoint(x: 7.87, y: 42.1), controlPoint1: CGPoint(x: 12.01, y: 42.75), controlPoint2: CGPoint(x: 9.83, y: 42.75))
        outlinePath.addLine(to: CGPoint(x: 7.49, y: 42.01))
        outlinePath.addCurve(to: CGPoint(x: 1.99, y: 36.51), controlPoint1: CGPoint(x: 4.93, y: 41.08), controlPoint2: CGPoint(x: 2.92, y: 39.07))
        outlinePath.addCurve(to: CGPoint(x: 1.25, y: 27.65), controlPoint1: CGPoint(x: 1.25, y: 34.17), controlPoint2: CGPoint(x: 1.25, y: 31.99))
        outlinePath.addLine(to: CGPoint(x: 1.25, y: 16.35))
        outlinePath.addCurve(to: CGPoint(x: 1.9, y: 7.87), controlPoint1: CGPoint(x: 1.25, y: 12.01), controlPoint2: CGPoint(x: 1.25, y: 9.83))
        outlinePath.addLine(to: CGPoint(x: 1.99, y: 7.49))
        outlinePath.addCurve(to: CGPoint(x: 7.49, y: 1.99), controlPoint1: CGPoint(x: 2.92, y: 4.93), controlPoint2: CGPoint(x: 4.93, y: 2.92))
        outlinePath.addCurve(to: CGPoint(x: 16.35, y: 1.25), controlPoint1: CGPoint(x: 9.83, y: 1.25), controlPoint2: CGPoint(x: 12.01, y: 1.25))
        outlinePath.close()
        tabBarFill.setStroke()
        outlinePath.lineWidth = 1
        outlinePath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawGreenRoundButton(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 44, height: 44), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 44, height: 44), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 44, y: resizedFrame.height / 44)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 44, resizedFrame.height / 44)


        //// Color Declarations
        let greenButtonBottomFill = UIColor(red: 0.145, green: 0.620, blue: 0.090, alpha: 1.000)
        let tabBarFill = UIColor(red: 0.502, green: 0.502, blue: 0.502, alpha: 1.000)
        let greenButtonTopFill = UIColor(red: 0.537, green: 0.776, blue: 0.514, alpha: 1.000)

        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = UIColor.black
        shadow.shadowOffset = CGSize(width: 0, height: 0)
        shadow.shadowBlurRadius = 1

        //// ShadowBackground Drawing
        let shadowBackgroundPath = UIBezierPath(roundedRect: CGRect(x: 1, y: 1, width: 42, height: 42), cornerRadius: 10)
        context.saveGState()
        context.setShadow(offset: CGSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: (shadow.shadowColor as! UIColor).cgColor)
        UIColor.gray.setFill()
        shadowBackgroundPath.fill()
        context.restoreGState()



        //// BottomFill Drawing
        let bottomFillPath = UIBezierPath()
        bottomFillPath.move(to: CGPoint(x: 43, y: 27.68))
        bottomFillPath.addCurve(to: CGPoint(x: 42.35, y: 36.3), controlPoint1: CGPoint(x: 43, y: 32.12), controlPoint2: CGPoint(x: 43, y: 34.32))
        bottomFillPath.addLine(to: CGPoint(x: 42.25, y: 36.69))
        bottomFillPath.addCurve(to: CGPoint(x: 36.69, y: 42.25), controlPoint1: CGPoint(x: 41.31, y: 39.27), controlPoint2: CGPoint(x: 39.27, y: 41.31))
        bottomFillPath.addCurve(to: CGPoint(x: 27.71, y: 43), controlPoint1: CGPoint(x: 34.32, y: 43), controlPoint2: CGPoint(x: 32.12, y: 43))
        bottomFillPath.addLine(to: CGPoint(x: 16.29, y: 43))
        bottomFillPath.addCurve(to: CGPoint(x: 7.7, y: 42.35), controlPoint1: CGPoint(x: 11.88, y: 43), controlPoint2: CGPoint(x: 9.68, y: 43))
        bottomFillPath.addLine(to: CGPoint(x: 7.31, y: 42.25))
        bottomFillPath.addCurve(to: CGPoint(x: 1.75, y: 36.69), controlPoint1: CGPoint(x: 4.73, y: 41.31), controlPoint2: CGPoint(x: 2.69, y: 39.27))
        bottomFillPath.addCurve(to: CGPoint(x: 1, y: 27.71), controlPoint1: CGPoint(x: 1, y: 34.32), controlPoint2: CGPoint(x: 1, y: 32.12))
        bottomFillPath.addCurve(to: CGPoint(x: 1, y: 22), controlPoint1: CGPoint(x: 1, y: 27.71), controlPoint2: CGPoint(x: 1, y: 24.86))
        bottomFillPath.addLine(to: CGPoint(x: 43, y: 22))
        bottomFillPath.addCurve(to: CGPoint(x: 43, y: 27.71), controlPoint1: CGPoint(x: 43, y: 24.86), controlPoint2: CGPoint(x: 43, y: 27.71))
        bottomFillPath.addLine(to: CGPoint(x: 43, y: 27.68))
        bottomFillPath.close()
        greenButtonBottomFill.setFill()
        bottomFillPath.fill()


        //// TopFill Drawing
        let topFillPath = UIBezierPath()
        topFillPath.move(to: CGPoint(x: 36.3, y: 1.65))
        topFillPath.addLine(to: CGPoint(x: 36.69, y: 1.75))
        topFillPath.addCurve(to: CGPoint(x: 42.25, y: 7.31), controlPoint1: CGPoint(x: 39.27, y: 2.69), controlPoint2: CGPoint(x: 41.31, y: 4.73))
        topFillPath.addCurve(to: CGPoint(x: 43, y: 16.29), controlPoint1: CGPoint(x: 43, y: 9.68), controlPoint2: CGPoint(x: 43, y: 11.88))
        topFillPath.addCurve(to: CGPoint(x: 43, y: 22), controlPoint1: CGPoint(x: 43, y: 16.29), controlPoint2: CGPoint(x: 43, y: 19.14))
        topFillPath.addLine(to: CGPoint(x: 1, y: 22))
        topFillPath.addCurve(to: CGPoint(x: 1, y: 16.29), controlPoint1: CGPoint(x: 1, y: 19.14), controlPoint2: CGPoint(x: 1, y: 16.29))
        topFillPath.addCurve(to: CGPoint(x: 1.65, y: 7.7), controlPoint1: CGPoint(x: 1, y: 11.88), controlPoint2: CGPoint(x: 1, y: 9.68))
        topFillPath.addLine(to: CGPoint(x: 1.75, y: 7.31))
        topFillPath.addCurve(to: CGPoint(x: 7.31, y: 1.75), controlPoint1: CGPoint(x: 2.69, y: 4.73), controlPoint2: CGPoint(x: 4.73, y: 2.69))
        topFillPath.addCurve(to: CGPoint(x: 16.29, y: 1), controlPoint1: CGPoint(x: 9.68, y: 1), controlPoint2: CGPoint(x: 11.88, y: 1))
        topFillPath.addLine(to: CGPoint(x: 27.71, y: 1))
        topFillPath.addCurve(to: CGPoint(x: 36.3, y: 1.65), controlPoint1: CGPoint(x: 32.12, y: 1), controlPoint2: CGPoint(x: 34.32, y: 1))
        topFillPath.close()
        greenButtonTopFill.setFill()
        topFillPath.fill()


        //// Outline Drawing
        let outlinePath = UIBezierPath()
        outlinePath.move(to: CGPoint(x: 16.35, y: 1.25))
        outlinePath.addLine(to: CGPoint(x: 27.65, y: 1.25))
        outlinePath.addCurve(to: CGPoint(x: 36.13, y: 1.9), controlPoint1: CGPoint(x: 31.99, y: 1.25), controlPoint2: CGPoint(x: 34.17, y: 1.25))
        outlinePath.addLine(to: CGPoint(x: 36.51, y: 1.99))
        outlinePath.addCurve(to: CGPoint(x: 42.01, y: 7.49), controlPoint1: CGPoint(x: 39.07, y: 2.92), controlPoint2: CGPoint(x: 41.08, y: 4.93))
        outlinePath.addCurve(to: CGPoint(x: 42.75, y: 16.35), controlPoint1: CGPoint(x: 42.75, y: 9.83), controlPoint2: CGPoint(x: 42.75, y: 12.01))
        outlinePath.addLine(to: CGPoint(x: 42.75, y: 27.65))
        outlinePath.addCurve(to: CGPoint(x: 42.1, y: 36.13), controlPoint1: CGPoint(x: 42.75, y: 31.99), controlPoint2: CGPoint(x: 42.75, y: 34.17))
        outlinePath.addLine(to: CGPoint(x: 42.01, y: 36.51))
        outlinePath.addCurve(to: CGPoint(x: 36.51, y: 42.01), controlPoint1: CGPoint(x: 41.08, y: 39.07), controlPoint2: CGPoint(x: 39.07, y: 41.08))
        outlinePath.addCurve(to: CGPoint(x: 27.65, y: 42.75), controlPoint1: CGPoint(x: 34.17, y: 42.75), controlPoint2: CGPoint(x: 31.99, y: 42.75))
        outlinePath.addLine(to: CGPoint(x: 16.35, y: 42.75))
        outlinePath.addCurve(to: CGPoint(x: 7.87, y: 42.1), controlPoint1: CGPoint(x: 12.01, y: 42.75), controlPoint2: CGPoint(x: 9.83, y: 42.75))
        outlinePath.addLine(to: CGPoint(x: 7.49, y: 42.01))
        outlinePath.addCurve(to: CGPoint(x: 1.99, y: 36.51), controlPoint1: CGPoint(x: 4.93, y: 41.08), controlPoint2: CGPoint(x: 2.92, y: 39.07))
        outlinePath.addCurve(to: CGPoint(x: 1.25, y: 27.65), controlPoint1: CGPoint(x: 1.25, y: 34.17), controlPoint2: CGPoint(x: 1.25, y: 31.99))
        outlinePath.addLine(to: CGPoint(x: 1.25, y: 16.35))
        outlinePath.addCurve(to: CGPoint(x: 1.9, y: 7.87), controlPoint1: CGPoint(x: 1.25, y: 12.01), controlPoint2: CGPoint(x: 1.25, y: 9.83))
        outlinePath.addLine(to: CGPoint(x: 1.99, y: 7.49))
        outlinePath.addCurve(to: CGPoint(x: 7.49, y: 1.99), controlPoint1: CGPoint(x: 2.92, y: 4.93), controlPoint2: CGPoint(x: 4.93, y: 2.92))
        outlinePath.addCurve(to: CGPoint(x: 16.35, y: 1.25), controlPoint1: CGPoint(x: 9.83, y: 1.25), controlPoint2: CGPoint(x: 12.01, y: 1.25))
        outlinePath.close()
        tabBarFill.setStroke()
        outlinePath.lineWidth = 1
        outlinePath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawPanelBackground(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 100, height: 100), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 100, height: 100), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 100, y: resizedFrame.height / 100)


        //// Color Declarations
        let tabBarFill = UIColor(red: 0.502, green: 0.502, blue: 0.502, alpha: 1.000)
        let gradientColor = UIColor(red: 0.753, green: 0.753, blue: 0.753, alpha: 1.000)

        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [UIColor.white.cgColor, UIColor.white.blended(withFraction: 0.5, of: gradientColor).cgColor, gradientColor.cgColor] as CFArray, locations: [0.15, 0.41, 1])!

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRect(x: 2, y: 2, width: 96, height: 96), cornerRadius: 26)
        context.saveGState()
        rectanglePath.addClip()
        context.drawLinearGradient(gradient, start: CGPoint(x: 50, y: 2), end: CGPoint(x: 50, y: 98), options: [])
        context.restoreGState()
        tabBarFill.setStroke()
        rectanglePath.lineWidth = 2
        rectanglePath.stroke()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawIncomingMessageBubble(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 92, height: 58), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 92, height: 58), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 92, y: resizedFrame.height / 58)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 92, resizedFrame.height / 58)


        //// Color Declarations
        let gradient3Color7 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.251)
        let messageBubbleFadeColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let gradient3Color8 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let gradient3Color5 = UIColor(red: 0.663, green: 0.792, blue: 0.933, alpha: 1.000)
        let gradient3Color6 = UIColor(red: 0.788, green: 0.871, blue: 0.969, alpha: 1.000)

        //// Gradient Declarations
        let messageBubbleFade = CGGradient(colorsSpace: nil, colors: [gradient3Color7.cgColor, gradient3Color7.blended(withFraction: 0.5, of: messageBubbleFadeColor).cgColor, messageBubbleFadeColor.cgColor, gradient3Color8.cgColor] as CFArray, locations: [0, 0.13, 0.5, 1])!
        let messageInGradient = CGGradient(colorsSpace: nil, colors: [gradient3Color5.cgColor, gradient3Color6.cgColor] as CFArray, locations: [0, 1])!

        //// Shadow Declarations
        let messageBlockShadow = NSShadow()
        messageBlockShadow.shadowColor = UIColor.black.withAlphaComponent(0.5)
        messageBlockShadow.shadowOffset = CGSize(width: 0, height: 0)
        messageBlockShadow.shadowBlurRadius = 3

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath()
        rectanglePath.move(to: CGPoint(x: 55.54, y: 4))
        rectanglePath.addLine(to: CGPoint(x: 32.46, y: 4))
        rectanglePath.addCurve(to: CGPoint(x: 18.72, y: 5.05), controlPoint1: CGPoint(x: 25.42, y: 4), controlPoint2: CGPoint(x: 21.89, y: 4))
        rectanglePath.addLine(to: CGPoint(x: 18.1, y: 5.2))
        rectanglePath.addCurve(to: CGPoint(x: 9.2, y: 14.1), controlPoint1: CGPoint(x: 13.97, y: 6.7), controlPoint2: CGPoint(x: 10.7, y: 9.97))
        rectanglePath.addCurve(to: CGPoint(x: 8, y: 28.46), controlPoint1: CGPoint(x: 8, y: 17.89), controlPoint2: CGPoint(x: 8, y: 21.42))
        rectanglePath.addLine(to: CGPoint(x: 8, y: 29.54))
        rectanglePath.addCurve(to: CGPoint(x: 9.05, y: 43.28), controlPoint1: CGPoint(x: 8, y: 36.58), controlPoint2: CGPoint(x: 8, y: 40.11))
        rectanglePath.addLine(to: CGPoint(x: 9.2, y: 43.9))
        rectanglePath.addCurve(to: CGPoint(x: 4, y: 53), controlPoint1: CGPoint(x: 9, y: 48), controlPoint2: CGPoint(x: 7.5, y: 49.5))
        rectanglePath.addCurve(to: CGPoint(x: 10, y: 52), controlPoint1: CGPoint(x: 6, y: 53), controlPoint2: CGPoint(x: 7.42, y: 53.29))
        rectanglePath.addCurve(to: CGPoint(x: 18.1, y: 52.8), controlPoint1: CGPoint(x: 14, y: 50), controlPoint2: CGPoint(x: 15, y: 51))
        rectanglePath.addCurve(to: CGPoint(x: 32.46, y: 54), controlPoint1: CGPoint(x: 21.89, y: 54), controlPoint2: CGPoint(x: 25.42, y: 54))
        rectanglePath.addLine(to: CGPoint(x: 55.54, y: 54))
        rectanglePath.addCurve(to: CGPoint(x: 69.28, y: 52.95), controlPoint1: CGPoint(x: 62.58, y: 54), controlPoint2: CGPoint(x: 66.11, y: 54))
        rectanglePath.addLine(to: CGPoint(x: 69.9, y: 52.8))
        rectanglePath.addCurve(to: CGPoint(x: 78.8, y: 43.9), controlPoint1: CGPoint(x: 74.03, y: 51.3), controlPoint2: CGPoint(x: 77.3, y: 48.03))
        rectanglePath.addCurve(to: CGPoint(x: 80, y: 29.54), controlPoint1: CGPoint(x: 80, y: 40.11), controlPoint2: CGPoint(x: 80, y: 36.58))
        rectanglePath.addLine(to: CGPoint(x: 80, y: 28.46))
        rectanglePath.addCurve(to: CGPoint(x: 78.95, y: 14.72), controlPoint1: CGPoint(x: 80, y: 21.42), controlPoint2: CGPoint(x: 80, y: 17.89))
        rectanglePath.addLine(to: CGPoint(x: 78.8, y: 14.1))
        rectanglePath.addCurve(to: CGPoint(x: 69.9, y: 5.2), controlPoint1: CGPoint(x: 77.3, y: 9.97), controlPoint2: CGPoint(x: 74.03, y: 6.7))
        rectanglePath.addCurve(to: CGPoint(x: 55.54, y: 4), controlPoint1: CGPoint(x: 66.11, y: 4), controlPoint2: CGPoint(x: 62.58, y: 4))
        rectanglePath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: messageBlockShadow.shadowOffset.width * resizedShadowScale, height: messageBlockShadow.shadowOffset.height * resizedShadowScale), blur: messageBlockShadow.shadowBlurRadius * resizedShadowScale, color: (messageBlockShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(messageInGradient, start: CGPoint(x: 42, y: 4), end: CGPoint(x: 42, y: 54), options: [])
        context.endTransparencyLayer()
        context.restoreGState()



        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: 12, y: 6, width: 62, height: 20), cornerRadius: 10)
        context.saveGState()
        rectangle2Path.addClip()
        context.drawLinearGradient(messageBubbleFade, start: CGPoint(x: 43, y: 6), end: CGPoint(x: 43, y: 26), options: [])
        context.restoreGState()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawOutgoingMessageBubble(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 82, height: 58), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 82, height: 58), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 82, y: resizedFrame.height / 58)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 82, resizedFrame.height / 58)


        //// Color Declarations
        let messageOutGradientColor = UIColor(red: 0.690, green: 0.749, blue: 0.757, alpha: 1.000)
        let messageOutGradientColor2 = UIColor(red: 0.820, green: 0.863, blue: 0.867, alpha: 1.000)
        let gradient3Color7 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.251)
        let messageBubbleFadeColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let gradient3Color8 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        let messageBlockHighlightColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let messageOutGradient = CGGradient(colorsSpace: nil, colors: [messageOutGradientColor.cgColor, messageOutGradientColor2.cgColor] as CFArray, locations: [0, 1])!
        let messageBubbleFade = CGGradient(colorsSpace: nil, colors: [gradient3Color7.cgColor, gradient3Color7.blended(withFraction: 0.5, of: messageBubbleFadeColor).cgColor, messageBubbleFadeColor.cgColor, gradient3Color8.cgColor] as CFArray, locations: [0, 0.13, 0.5, 1])!

        //// Shadow Declarations
        let messageBlockHighlight = NSShadow()
        messageBlockHighlight.shadowColor = messageBlockHighlightColor
        messageBlockHighlight.shadowOffset = CGSize(width: 0, height: 0)
        messageBlockHighlight.shadowBlurRadius = 10
        let messageBlockShadow = NSShadow()
        messageBlockShadow.shadowColor = UIColor.black.withAlphaComponent(0.5)
        messageBlockShadow.shadowOffset = CGSize(width: 0, height: 0)
        messageBlockShadow.shadowBlurRadius = 3

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath()
        rectanglePath.move(to: CGPoint(x: 28.46, y: 4))
        rectanglePath.addLine(to: CGPoint(x: 51.54, y: 4))
        rectanglePath.addCurve(to: CGPoint(x: 65.28, y: 5.05), controlPoint1: CGPoint(x: 58.58, y: 4), controlPoint2: CGPoint(x: 62.11, y: 4))
        rectanglePath.addLine(to: CGPoint(x: 65.9, y: 5.2))
        rectanglePath.addCurve(to: CGPoint(x: 74.8, y: 14.1), controlPoint1: CGPoint(x: 70.03, y: 6.7), controlPoint2: CGPoint(x: 73.3, y: 9.97))
        rectanglePath.addCurve(to: CGPoint(x: 76, y: 28.46), controlPoint1: CGPoint(x: 76, y: 17.89), controlPoint2: CGPoint(x: 76, y: 21.42))
        rectanglePath.addLine(to: CGPoint(x: 76, y: 29.54))
        rectanglePath.addCurve(to: CGPoint(x: 74.95, y: 43.28), controlPoint1: CGPoint(x: 76, y: 36.58), controlPoint2: CGPoint(x: 76, y: 40.11))
        rectanglePath.addLine(to: CGPoint(x: 74.8, y: 43.9))
        rectanglePath.addCurve(to: CGPoint(x: 80, y: 53), controlPoint1: CGPoint(x: 75, y: 48), controlPoint2: CGPoint(x: 76.5, y: 49.5))
        rectanglePath.addCurve(to: CGPoint(x: 74, y: 52), controlPoint1: CGPoint(x: 78, y: 53), controlPoint2: CGPoint(x: 76.58, y: 53.29))
        rectanglePath.addCurve(to: CGPoint(x: 65.9, y: 52.8), controlPoint1: CGPoint(x: 70, y: 50), controlPoint2: CGPoint(x: 69, y: 51))
        rectanglePath.addCurve(to: CGPoint(x: 51.54, y: 54), controlPoint1: CGPoint(x: 62.11, y: 54), controlPoint2: CGPoint(x: 58.58, y: 54))
        rectanglePath.addLine(to: CGPoint(x: 28.46, y: 54))
        rectanglePath.addCurve(to: CGPoint(x: 14.72, y: 52.95), controlPoint1: CGPoint(x: 21.42, y: 54), controlPoint2: CGPoint(x: 17.89, y: 54))
        rectanglePath.addLine(to: CGPoint(x: 14.1, y: 52.8))
        rectanglePath.addCurve(to: CGPoint(x: 5.2, y: 43.9), controlPoint1: CGPoint(x: 9.97, y: 51.3), controlPoint2: CGPoint(x: 6.7, y: 48.03))
        rectanglePath.addCurve(to: CGPoint(x: 4, y: 29.54), controlPoint1: CGPoint(x: 4, y: 40.11), controlPoint2: CGPoint(x: 4, y: 36.58))
        rectanglePath.addLine(to: CGPoint(x: 4, y: 28.46))
        rectanglePath.addCurve(to: CGPoint(x: 5.05, y: 14.72), controlPoint1: CGPoint(x: 4, y: 21.42), controlPoint2: CGPoint(x: 4, y: 17.89))
        rectanglePath.addLine(to: CGPoint(x: 5.2, y: 14.1))
        rectanglePath.addCurve(to: CGPoint(x: 14.1, y: 5.2), controlPoint1: CGPoint(x: 6.7, y: 9.97), controlPoint2: CGPoint(x: 9.97, y: 6.7))
        rectanglePath.addCurve(to: CGPoint(x: 28.46, y: 4), controlPoint1: CGPoint(x: 17.89, y: 4), controlPoint2: CGPoint(x: 21.42, y: 4))
        rectanglePath.close()
        context.saveGState()
        context.setShadow(offset: CGSize(width: messageBlockShadow.shadowOffset.width * resizedShadowScale, height: messageBlockShadow.shadowOffset.height * resizedShadowScale), blur: messageBlockShadow.shadowBlurRadius * resizedShadowScale, color: (messageBlockShadow.shadowColor as! UIColor).cgColor)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        rectanglePath.addClip()
        context.drawLinearGradient(messageOutGradient, start: CGPoint(x: 42, y: 4), end: CGPoint(x: 42, y: 54), options: [])
        context.endTransparencyLayer()

        ////// Rectangle Inner Shadow
        context.saveGState()
        context.clip(to: rectanglePath.bounds)
        context.setShadow(offset: CGSize.zero, blur: 0)
        context.setAlpha((messageBlockHighlight.shadowColor as! UIColor).cgColor.alpha)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let rectangleOpaqueShadow = (messageBlockHighlight.shadowColor as! UIColor).withAlphaComponent(1)
        context.setShadow(offset: CGSize(width: messageBlockHighlight.shadowOffset.width * resizedShadowScale, height: messageBlockHighlight.shadowOffset.height * resizedShadowScale), blur: messageBlockHighlight.shadowBlurRadius * resizedShadowScale, color: rectangleOpaqueShadow.cgColor)
        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        rectangleOpaqueShadow.setFill()
        rectanglePath.fill()

        context.endTransparencyLayer()
        context.endTransparencyLayer()
        context.restoreGState()

        context.restoreGState()



        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(roundedRect: CGRect(x: 9, y: 6, width: 62, height: 20), cornerRadius: 10)
        context.saveGState()
        rectangle2Path.addClip()
        context.drawLinearGradient(messageBubbleFade, start: CGPoint(x: 40, y: 6), end: CGPoint(x: 40, y: 26), options: [])
        context.restoreGState()
        
        context.restoreGState()

    }

    //// Generated Images

    @objc dynamic public class func imageOfKeyPadAudioRoutes(imageSize: CGSize = CGSize(width: 100, height: 100), pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawKeyPadAudioRoutes(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), pressed: pressed, enabled: enabled)

        let imageOfKeyPadAudioRoutes = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadAudioRoutes
    }

    @objc dynamic public class func imageOfKeyPadBack(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadBack(pressed: pressed, enabled: enabled)

        let imageOfKeyPadBack = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadBack
    }

    @objc dynamic public class func imageOfKeyPad07(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad07(pressed: pressed, enabled: enabled)

        let imageOfKeyPad07 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad07
    }

    @objc dynamic public class func imageOfNumPad07(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad07(pressed: pressed, enabled: enabled)

        let imageOfNumPad07 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad07
    }

    @objc dynamic public class func imageOfKeyPad03(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad03(pressed: pressed, enabled: enabled)

        let imageOfKeyPad03 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad03
    }

    @objc dynamic public class func imageOfKeyPad06(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad06(pressed: pressed, enabled: enabled)

        let imageOfKeyPad06 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad06
    }

    @objc dynamic public class func imageOfKeyPadSpeaker(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadSpeaker(pressed: pressed, enabled: enabled)

        let imageOfKeyPadSpeaker = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadSpeaker
    }

    @objc dynamic public class func imageOfNumPad03(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad03(pressed: pressed, enabled: enabled)

        let imageOfNumPad03 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad03
    }

    @objc dynamic public class func imageOfKeyPad00(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad00(pressed: pressed, enabled: enabled)

        let imageOfKeyPad00 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad00
    }

    @objc dynamic public class func imageOfKeyPad01(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad01(pressed: pressed, enabled: enabled)

        let imageOfKeyPad01 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad01
    }

    @objc dynamic public class func imageOfKeyPadStop(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadStop(pressed: pressed, enabled: enabled)

        let imageOfKeyPadStop = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadStop
    }

    @objc dynamic public class func imageOfKeyPad05(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad05(pressed: pressed, enabled: enabled)

        let imageOfKeyPad05 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad05
    }

    @objc dynamic public class func imageOfKeyPadHash2(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadHash2(pressed: pressed, enabled: enabled)

        let imageOfKeyPadHash2 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadHash2
    }

    @objc dynamic public class func imageOfNumPad04(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad04(pressed: pressed, enabled: enabled)

        let imageOfNumPad04 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad04
    }

    @objc dynamic public class func imageOfKeyPad09(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad09(pressed: pressed, enabled: enabled)

        let imageOfKeyPad09 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad09
    }

    @objc dynamic public class func imageOfKeyPad04(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad04(pressed: pressed, enabled: enabled)

        let imageOfKeyPad04 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad04
    }

    @objc dynamic public class func imageOfKeyPadHash(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadHash(pressed: pressed, enabled: enabled)

        let imageOfKeyPadHash = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadHash
    }

    @objc dynamic public class func imageOfKeyPad02(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad02(pressed: pressed, enabled: enabled)

        let imageOfKeyPad02 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad02
    }

    @objc dynamic public class func imageOfKeyPadGo(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadGo(pressed: pressed, enabled: enabled)

        let imageOfKeyPadGo = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadGo
    }

    @objc dynamic public class func imageOfNumPad06(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad06(pressed: pressed, enabled: enabled)

        let imageOfNumPad06 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad06
    }

    @objc dynamic public class func imageOfNumPad01(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad01(pressed: pressed, enabled: enabled)

        let imageOfNumPad01 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad01
    }

    @objc dynamic public class func imageOfKeyPad08(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPad08(pressed: pressed, enabled: enabled)

        let imageOfKeyPad08 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPad08
    }

    @objc dynamic public class func imageOfKeyPadMute(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadMute(pressed: pressed, enabled: enabled)

        let imageOfKeyPadMute = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadMute
    }

    @objc dynamic public class func imageOfNumPad09(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad09(pressed: pressed, enabled: enabled)

        let imageOfNumPad09 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad09
    }

    @objc dynamic public class func imageOfKeyPadStar(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadStar(pressed: pressed, enabled: enabled)

        let imageOfKeyPadStar = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadStar
    }

    @objc dynamic public class func imageOfNumPad05(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad05(pressed: pressed, enabled: enabled)

        let imageOfNumPad05 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad05
    }

    @objc dynamic public class func imageOfNumPad02(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad02(pressed: pressed, enabled: enabled)

        let imageOfNumPad02 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad02
    }

    @objc dynamic public class func imageOfNumPad08(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad08(pressed: pressed, enabled: enabled)

        let imageOfNumPad08 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad08
    }

    @objc dynamic public class func imageOfKeyPadStar2(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadStar2(pressed: pressed, enabled: enabled)

        let imageOfKeyPadStar2 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadStar2
    }

    @objc dynamic public class func imageOfNumPad00(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawNumPad00(pressed: pressed, enabled: enabled)

        let imageOfNumPad00 = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfNumPad00
    }

    @objc dynamic public class func imageOfKeyPadNumPad(pressed: Bool = false, enabled: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawKeyPadNumPad(pressed: pressed, enabled: enabled)

        let imageOfKeyPadNumPad = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfKeyPadNumPad
    }

    @objc dynamic public class func imageOfLogoLoader(cycleProgress: CGFloat = 0) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 300, height: 300), false, 0)
            Examples.drawLogoLoader(cycleProgress: cycleProgress)

        let imageOfLogoLoader = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfLogoLoader
    }

    @objc dynamic public class func imageOfBatteryDischargingStatus(batteryCharge: CGFloat = 0.5) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 46, height: 22), false, 0)
            Examples.drawBatteryDischargingStatus(batteryCharge: batteryCharge)

        let imageOfBatteryDischargingStatus = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfBatteryDischargingStatus
    }

    @objc dynamic public class func imageOfBatteryChargingStatus(batteryCharge: CGFloat = 0.5) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 46, height: 22), false, 0)
            Examples.drawBatteryChargingStatus(batteryCharge: batteryCharge)

        let imageOfBatteryChargingStatus = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfBatteryChargingStatus
    }

    @objc dynamic public class func imageOfBatteryAnimatedCharging(batteryCharge: CGFloat = 0.5, batteryChargeTextValue: String = "50%") -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 46, height: 22), false, 0)
            Examples.drawBatteryAnimatedCharging(batteryCharge: batteryCharge, batteryChargeTextValue: batteryChargeTextValue)

        let imageOfBatteryAnimatedCharging = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfBatteryAnimatedCharging
    }

    @objc dynamic public class func imageOfSignalStrength(signalStrengthValue: CGFloat = 5) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 40, height: 22), false, 0)
            Examples.drawSignalStrength(signalStrengthValue: signalStrengthValue)

        let imageOfSignalStrength = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfSignalStrength
    }

    @objc dynamic public class func imageOfActiveCallButton09(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton09(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton09 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton09
    }

    @objc dynamic public class func imageOfActiveCallKeypad(pressed2: Bool = true, keypadText: String = "Keypad") -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 192, height: 211), false, 0)
            Examples.drawActiveCallKeypad(pressed2: pressed2, keypadText: keypadText)

        let imageOfActiveCallKeypad = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallKeypad
    }

    @objc dynamic public class func imageOfDialPadDelete(imageSize: CGSize = CGSize(width: 162, height: 100), pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadDelete(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), pressed2: pressed2)

        let imageOfDialPadDelete = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadDelete
    }

    @objc dynamic public class func imageOfDialPadNumber01(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber01(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber01 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber01
    }

    @objc dynamic public class func imageOfDialPadNumber00(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber00(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber00 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber00
    }

    @objc dynamic public class func imageOfActiveCallSpeaker(speakerText: String = "Speaker", pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 192, height: 211), false, 0)
            Examples.drawActiveCallSpeaker(speakerText: speakerText, pressed2: pressed2)

        let imageOfActiveCallSpeaker = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallSpeaker
    }

    @objc dynamic public class func imageOfActiveCallButton07(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton07(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton07 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton07
    }

    @objc dynamic public class var imageOfActiveCallBlank: UIImage {
        if Cache.imageOfActiveCallBlank != nil {
            return Cache.imageOfActiveCallBlank!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 192, height: 211), false, 0)
            Examples.drawActiveCallBlank()

        Cache.imageOfActiveCallBlank = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return Cache.imageOfActiveCallBlank!
    }

    @objc dynamic public class func imageOfDialPadNumber08(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber08(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber08 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber08
    }

    @objc dynamic public class func imageOfActiveCallButton03(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton03(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton03 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton03
    }

    @objc dynamic public class func imageOfDialPadNumber09(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber09(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber09 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber09
    }

    @objc dynamic public class func imageOfActiveCallButton02(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton02(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton02 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton02
    }

    @objc dynamic public class func imageOfDialPadStar(imageSize: CGSize = CGSize(width: 162, height: 100), pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadStar(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), pressed2: pressed2)

        let imageOfDialPadStar = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadStar
    }

    @objc dynamic public class func imageOfDialPadNumber06(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber06(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber06 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber06
    }

    @objc dynamic public class func imageOfActiveCallButton01(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton01(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton01 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton01
    }

    @objc dynamic public class func imageOfDialPadNumber05(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber05(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber05 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber05
    }

    @objc dynamic public class func imageOfActiveCallButton00(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton00(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton00 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton00
    }

    @objc dynamic public class func imageOfActiveCallTransfer(callTransferText: String = "Transfer", pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 192, height: 211), false, 0)
            Examples.drawActiveCallTransfer(callTransferText: callTransferText, pressed2: pressed2)

        let imageOfActiveCallTransfer = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallTransfer
    }

    @objc dynamic public class func imageOfActiveCallButtonHash(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButtonHash(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButtonHash = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButtonHash
    }

    @objc dynamic public class func imageOfDialPadNumber03(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber03(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber03 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber03
    }

    @objc dynamic public class func imageOfActiveCallButton05(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton05(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton05 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton05
    }

    @objc dynamic public class func imageOfActiveCallButton04(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton04(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton04 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton04
    }

    @objc dynamic public class func imageOfDialPadHash(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadHash(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadHash = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadHash
    }

    @objc dynamic public class func imageOfActiveCallBlueTooth(blueToothText: String = "Bluetooth", pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 192, height: 211), false, 0)
            Examples.drawActiveCallBlueTooth(blueToothText: blueToothText, pressed2: pressed2)

        let imageOfActiveCallBlueTooth = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallBlueTooth
    }

    @objc dynamic public class func imageOfDialPadCall(imageSize: CGSize = CGSize(width: 162, height: 100), pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadCall(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), pressed2: pressed2)

        let imageOfDialPadCall = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadCall
    }

    @objc dynamic public class func imageOfDialPadNumber02(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber02(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber02 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber02
    }

    @objc dynamic public class func imageOfDialPadContact(imageSize: CGSize = CGSize(width: 162, height: 100), add: Bool = true, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadContact(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), add: add, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadContact = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadContact
    }

    @objc dynamic public class func imageOfActiveCallMute(muteText: String = "Mute", pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 192, height: 211), false, 0)
            Examples.drawActiveCallMute(muteText: muteText, pressed2: pressed2)

        let imageOfActiveCallMute = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallMute
    }

    @objc dynamic public class func imageOfDialPadNumber07(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber07(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber07 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber07
    }

    @objc dynamic public class func imageOfActiveCallButtonStar(imageSize: CGSize = CGSize(width: 160, height: 106), pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButtonStar(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), pressed2: pressed2)

        let imageOfActiveCallButtonStar = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButtonStar
    }

    @objc dynamic public class func imageOfActiveCallButton08(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton08(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton08 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton08
    }

    @objc dynamic public class func imageOfDialPadNumber04(imageSize: CGSize = CGSize(width: 162, height: 100), dialPadMainTextSize: CGFloat = 50, pressed2: Bool = true, dialPadSubTextSize: CGFloat = 25) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawDialPadNumber04(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), dialPadMainTextSize: dialPadMainTextSize, pressed2: pressed2, dialPadSubTextSize: dialPadSubTextSize)

        let imageOfDialPadNumber04 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfDialPadNumber04
    }

    @objc dynamic public class func imageOfActiveCallButton06(imageSize: CGSize = CGSize(width: 160, height: 106), activeCallMainTextFontSize: CGFloat = 65, activeCallSubTextFontSize: CGFloat = 21, pressed2: Bool = true) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            Examples.drawActiveCallButton06(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), activeCallMainTextFontSize: activeCallMainTextFontSize, activeCallSubTextFontSize: activeCallSubTextFontSize, pressed2: pressed2)

        let imageOfActiveCallButton06 = UIGraphicsGetImageFromCurrentImageContext()!.withRenderingMode(.alwaysOriginal)
        UIGraphicsEndImageContext()

        return imageOfActiveCallButton06
    }

    @objc dynamic public class var imageOfRoundButton: UIImage {
        if Cache.imageOfRoundButton != nil {
            return Cache.imageOfRoundButton!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 44, height: 44), false, 0)
            Examples.drawRoundButton()

        Cache.imageOfRoundButton = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets(top: 13, left: 13, bottom: 14, right: 14), resizingMode: .stretch)
        UIGraphicsEndImageContext()

        return Cache.imageOfRoundButton!
    }

    @objc dynamic public class var imageOfSOSRoundButton: UIImage {
        if Cache.imageOfSOSRoundButton != nil {
            return Cache.imageOfSOSRoundButton!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 44, height: 44), false, 0)
            Examples.drawSOSRoundButton()

        Cache.imageOfSOSRoundButton = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets(top: 13, left: 13, bottom: 14, right: 14), resizingMode: .stretch)
        UIGraphicsEndImageContext()

        return Cache.imageOfSOSRoundButton!
    }

    @objc dynamic public class var imageOfGreenRoundButton: UIImage {
        if Cache.imageOfGreenRoundButton != nil {
            return Cache.imageOfGreenRoundButton!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 44, height: 44), false, 0)
            Examples.drawGreenRoundButton()

        Cache.imageOfGreenRoundButton = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets(top: 13, left: 13, bottom: 14, right: 14), resizingMode: .stretch)
        UIGraphicsEndImageContext()

        return Cache.imageOfGreenRoundButton!
    }

    @objc dynamic public class var imageOfPanelBackground: UIImage {
        if Cache.imageOfPanelBackground != nil {
            return Cache.imageOfPanelBackground!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 100, height: 100), false, 0)
            Examples.drawPanelBackground()

        Cache.imageOfPanelBackground = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets(top: 40, left: 30, bottom: 35, right: 30), resizingMode: .stretch)
        UIGraphicsEndImageContext()

        return Cache.imageOfPanelBackground!
    }

    @objc dynamic public class var imageOfIncomingMessageBubble: UIImage {
        if Cache.imageOfIncomingMessageBubble != nil {
            return Cache.imageOfIncomingMessageBubble!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 92, height: 58), false, 0)
            Examples.drawIncomingMessageBubble()

        Cache.imageOfIncomingMessageBubble = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets(top: 26, left: 27, bottom: 22, right: 25), resizingMode: .stretch)
        UIGraphicsEndImageContext()

        return Cache.imageOfIncomingMessageBubble!
    }

    @objc dynamic public class var imageOfOutgoingMessageBubble: UIImage {
        if Cache.imageOfOutgoingMessageBubble != nil {
            return Cache.imageOfOutgoingMessageBubble!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 82, height: 58), false, 0)
            Examples.drawOutgoingMessageBubble()

        Cache.imageOfOutgoingMessageBubble = UIGraphicsGetImageFromCurrentImageContext()!.resizableImage(withCapInsets: UIEdgeInsets(top: 26, left: 25, bottom: 22, right: 25), resizingMode: .stretch)
        UIGraphicsEndImageContext()

        return Cache.imageOfOutgoingMessageBubble!
    }

    //// Customization Infrastructure

    @objc @IBOutlet dynamic var activeCallBlankTargets: [AnyObject]! {
        get { return Cache.activeCallBlankTargets }
        set {
            Cache.activeCallBlankTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfActiveCallBlank)
            }
        }
    }

    @objc @IBOutlet dynamic var roundButtonTargets: [AnyObject]! {
        get { return Cache.roundButtonTargets }
        set {
            Cache.roundButtonTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfRoundButton)
            }
        }
    }

    @objc @IBOutlet dynamic var sOSRoundButtonTargets: [AnyObject]! {
        get { return Cache.sOSRoundButtonTargets }
        set {
            Cache.sOSRoundButtonTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfSOSRoundButton)
            }
        }
    }

    @objc @IBOutlet dynamic var greenRoundButtonTargets: [AnyObject]! {
        get { return Cache.greenRoundButtonTargets }
        set {
            Cache.greenRoundButtonTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfGreenRoundButton)
            }
        }
    }

    @objc @IBOutlet dynamic var panelBackgroundTargets: [AnyObject]! {
        get { return Cache.panelBackgroundTargets }
        set {
            Cache.panelBackgroundTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfPanelBackground)
            }
        }
    }

    @objc @IBOutlet dynamic var incomingMessageBubbleTargets: [AnyObject]! {
        get { return Cache.incomingMessageBubbleTargets }
        set {
            Cache.incomingMessageBubbleTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfIncomingMessageBubble)
            }
        }
    }

    @objc @IBOutlet dynamic var outgoingMessageBubbleTargets: [AnyObject]! {
        get { return Cache.outgoingMessageBubbleTargets }
        set {
            Cache.outgoingMessageBubbleTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: Examples.imageOfOutgoingMessageBubble)
            }
        }
    }




    @objc(ExamplesResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
